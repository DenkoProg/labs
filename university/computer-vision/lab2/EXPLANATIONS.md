# –ü–æ—è—Å–Ω–µ–Ω–Ω—è –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ—ó –†–æ–±–æ—Ç–∏ 2 - ORB Feature Matching

## –ó–º—ñ—Å—Ç

1. [–ó–∞–≥–∞–ª—å–Ω–∏–π –æ–≥–ª—è–¥](#–∑–∞–≥–∞–ª—å–Ω–∏–π-–æ–≥–ª—è–¥)
2. [–¢–µ–æ—Ä–µ—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏](#—Ç–µ–æ—Ä–µ—Ç–∏—á–Ω—ñ-–æ—Å–Ω–æ–≤–∏)
3. [–î–µ—Ç–∞–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤](#–¥–µ—Ç–∞–ª—å–Ω–∏–π-–∞–Ω–∞–ª—ñ–∑-–∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤)
4. [–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ —Ñ–æ—Ä–º—É–ª–∏](#–º–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ-—Ñ–æ—Ä–º—É–ª–∏)
5. [–ê–Ω–∞–ª—ñ–∑ –∫–æ–¥—É](#–∞–Ω–∞–ª—ñ–∑-–∫–æ–¥—É)
6. [–ú–æ–∂–ª–∏–≤—ñ –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è](#–º–æ–∂–ª–∏–≤—ñ-–ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è)

---

## –ó–∞–≥–∞–ª—å–Ω–∏–π –æ–≥–ª—è–¥

### –ú–µ—Ç–∞ —Ä–æ–±–æ—Ç–∏

–†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤–ª–∞—Å–Ω–æ–≥–æ ORB (Oriented FAST and Rotated BRIEF) –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è —Ç–∞ –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∫–ª—é—á–æ–≤–∏—Ö —Ç–æ—á–æ–∫ –Ω–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è—Ö –∑ –ø–æ–¥–∞–ª—å—à–∏–º –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è–º –∑ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—î—é OpenCV.

### –û—Å–Ω–æ–≤–Ω—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —Å–∏—Å—Ç–µ–º–∏

1. **Feature Detection** - –≤–∏—è–≤–ª–µ–Ω–Ω—è –∫–ª—é—á–æ–≤–∏—Ö —Ç–æ—á–æ–∫ (FAST detector)
2. **Feature Description** - –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤ (Oriented BRIEF)
3. **Feature Matching** - –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤ (Hash based matcher + Lowe's ratio test)
4. **Geometric Verification** - RANSAC –¥–ª—è –∞—Ñ—ñ–Ω–Ω–∏—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ–π

---

## –¢–µ–æ—Ä–µ—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏

### 1. FAST (Features from Accelerated Segment Test)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –®–≤–∏–¥–∫–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è –∫—É—Ç–æ–≤–∏—Ö —Ç–æ—á–æ–∫ –Ω–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ.

**–ü—Ä–∏–Ω—Ü–∏–ø —Ä–æ–±–æ—Ç–∏**:

- –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è `p` —Ä–æ–∑–≥–ª—è–¥–∞—î—Ç—å—Å—è –∫–æ–ª–æ –∑ 16 –ø—ñ–∫—Å–µ–ª—ñ–≤ –Ω–∞–≤–∫–æ–ª–æ –Ω—å–æ–≥–æ (—Ä–∞–¥—ñ—É—Å 3)
- –ü—ñ–∫—Å–µ–ª—ñ –Ω—É–º–µ—Ä—É—é—Ç—å—Å—è –≤—ñ–¥ 1 –¥–æ 16 –ø–æ –∫–æ–ª—É
- –¢–æ—á–∫–∞ `p` –≤–≤–∞–∂–∞—î—Ç—å—Å—è –∫—É—Ç–æ–º, —è–∫—â–æ —ñ—Å–Ω—É—î –Ω–∞–±—ñ—Ä –∑ `N` –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏—Ö –ø—ñ–∫—Å–µ–ª—ñ–≤ –Ω–∞ –∫–æ–ª—ñ, —è–∫—ñ –≤—Å—ñ —è—Å–∫—Ä–∞–≤—ñ—à—ñ –∞–±–æ –≤—Å—ñ —Ç–µ–º–Ω—ñ—à—ñ –∑–∞ `p` –Ω–∞ –≤–µ–ª–∏—á–∏–Ω—É –ø–æ—Ä–æ–≥—É `t`

**–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ**:

```
–ö—É—Ç –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —è–∫—â–æ ‚àÉ –º–Ω–æ–∂–∏–Ω–∞ S –∑ N –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏—Ö –ø—ñ–∫—Å–µ–ª—ñ–≤ –¥–µ:
‚àÄ x ‚àà S: I(x) > I(p) + t  –ê–ë–û  I(x) < I(p) - t

–¥–µ:
- I(x) - —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –ø—ñ–∫—Å–µ–ª—è x
- I(p) - —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ –ø—ñ–∫—Å–µ–ª—è
- t - –ø–æ—Ä—ñ–≥ (threshold)
- N - –∑–∞–∑–≤–∏—á–∞–π 12 –¥–ª—è FAST-12 –∞–±–æ 9 –¥–ª—è FAST-9
```

**–ü–µ—Ä–µ–≤–∞–≥–∏**:

- ‚ö° –î—É–∂–µ —à–≤–∏–¥–∫–∏–π (–º–æ–∂–Ω–∞ —Ä–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —á–µ—Ä–µ–∑ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è)
- üéØ –î–æ–±—Ä–µ –≤–∏—è–≤–ª—è—î –∫—É—Ç–∏
- üîÑ –ü—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è real-time –∑–∞—Å—Ç–æ—Å—É–Ω–∫—ñ–≤

**–ù–µ–¥–æ–ª—ñ–∫–∏**:

- ‚ùå –ù–µ —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–Ω–∏–π –¥–æ –º–∞—Å—à—Ç–∞–±—É (–ø–æ—Ç—Ä—ñ–±–Ω–∞ –ø—ñ—Ä–∞–º—ñ–¥–∞)
- ‚ùå –ß—É—Ç–ª–∏–≤–∏–π –¥–æ —à—É–º—É
- ‚ùå –ë–∞–≥–∞—Ç–æ —Ö–∏–±–Ω–∏—Ö —Å–ø—Ä–∞—Ü—å–æ–≤—É–≤–∞–Ω—å –Ω–∞ –∫—Ä–∞—è—Ö

---

### 2. Gaussian Pyramid (–ü—ñ—Ä–∞–º—ñ–¥–∞ –∑–æ–±—Ä–∞–∂–µ–Ω—å)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –±–∞–≥–∞—Ç–æ–º–∞—Å—à—Ç–∞–±–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –¥–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è scale invariance.

**–ü–æ–±—É–¥–æ–≤–∞ –ø—ñ—Ä–∞–º—ñ–¥–∏**:

```
–†—ñ–≤–µ–Ω—å 0: I‚ÇÄ = I_original
–†—ñ–≤–µ–Ω—å 1: I‚ÇÅ = resize(I‚ÇÄ, 1/s)
–†—ñ–≤–µ–Ω—å 2: I‚ÇÇ = resize(I‚ÇÅ, 1/s)
...
–†—ñ–≤–µ–Ω—å k: I‚Çñ = resize(I‚Çñ‚Çã‚ÇÅ, 1/s)

–¥–µ s - scale_factor (–∑–∞–∑–≤–∏—á–∞–π 1.2)
```

**–†–æ–∑–º—ñ—Ä –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –Ω–∞ —Ä—ñ–≤–Ω—ñ k**:

```
width_k = width_0 / s^k
height_k = height_0 / s^k
```

**–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞–∑–∞–¥**:

```
–Ø–∫—â–æ keypoint –∑–Ω–∞–π–¥–µ–Ω–æ –Ω–∞ —Ä—ñ–≤–Ω—ñ k –∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ (x_k, y_k):
x_original = x_k √ó s^k
y_original = y_k √ó s^k
```

**–£ –∫–æ–¥—ñ**:

```python
def build_gaussian_pyramid(self, gray_img):
    pyramid = [gray_img]
    for level in range(1, self.n_levels):
        scale = 1.0 / (self.scale_factor ** level)
        new_size = (int(gray_img.shape[1] * scale),
                   int(gray_img.shape[0] * scale))
        if new_size[0] < self.patch_size or new_size[1] < self.patch_size:
            break
        scaled = cv2.resize(gray_img, new_size, interpolation=cv2.INTER_LINEAR)
        pyramid.append(scaled)
    return pyramid
```

**–ß–æ–º—É —Ü–µ –≤–∞–∂–ª–∏–≤–æ**:

- üîç –î–æ–∑–≤–æ–ª—è—î –≤–∏—è–≤–ª—è—Ç–∏ features —Ä—ñ–∑–Ω–∏—Ö —Ä–æ–∑–º—ñ—Ä—ñ–≤
- üìè –ó–∞–±–µ–∑–ø–µ—á—É—î scale invariance
- üéØ –†—ñ–≤–Ω–æ–º—ñ—Ä–Ω–∏–π —Ä–æ–∑–ø–æ–¥—ñ–ª features –ø–æ –º–∞—Å—à—Ç–∞–±–∞—Ö

---

### 3. Orientation via Intensity Centroid

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –û–±—á–∏—Å–ª–µ–Ω–Ω—è –∫–∞–Ω–æ–Ω—ñ—á–Ω–æ—ó –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó –¥–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è rotation invariance.

**–ú–æ–º–µ–Ω—Ç–∏ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ** (Image Moments):

```
–ú–æ–º–µ–Ω—Ç –ø–æ—Ä—è–¥–∫—É (p, q):
m_pq = Œ£ Œ£ x^p √ó y^q √ó I(x,y)
     x y

–¥–µ:
- (x, y) - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –≤—ñ–¥–Ω–æ—Å–Ω–æ —Ü–µ–Ω—Ç—Ä—É –ø–∞—Ç—á—É
- I(x,y) - —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –ø—ñ–∫—Å–µ–ª—è
- p, q - –ø–æ—Ä—è–¥–æ–∫ –º–æ–º–µ–Ω—Ç—É
```

**–û–±—á–∏—Å–ª–µ–Ω–Ω—è –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó**:

```
–ú–æ–º–µ–Ω—Ç–∏ –ø–µ—Ä—à–æ–≥–æ –ø–æ—Ä—è–¥–∫—É:
m‚ÇÅ‚ÇÄ = Œ£ Œ£ x √ó I(x,y)
     x y

m‚ÇÄ‚ÇÅ = Œ£ Œ£ y √ó I(x,y)
     x y

–ö—É—Ç –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó:
Œ∏ = atan2(m‚ÇÄ‚ÇÅ, m‚ÇÅ‚ÇÄ)

–¥–µ Œ∏ ‚àà [-œÄ, œÄ]
```

**–¶–µ–Ω—Ç—Ä–æ—ó–¥ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ** (Intensity Centroid):

```
C = (xÃÑ, »≥) –¥–µ:
xÃÑ = m‚ÇÅ‚ÇÄ / m‚ÇÄ‚ÇÄ
»≥ = m‚ÇÄ‚ÇÅ / m‚ÇÄ‚ÇÄ

–í–µ–∫—Ç–æ—Ä –≤—ñ–¥ —Ü–µ–Ω—Ç—Ä—É –ø–∞—Ç—á—É –¥–æ —Ü–µ–Ω—Ç—Ä–æ—ó–¥–∞ –≤–∏–∑–Ω–∞—á–∞—î –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é
```

**–£ –∫–æ–¥—ñ**:

```python
def compute_orientation(self, gray_img, keypoint):
    x, y = int(keypoint.pt[0]), int(keypoint.pt[1])
    half_patch = self.patch_size // 2

    # –í–∏—Ç—è–≥—É—î–º–æ –ø–∞—Ç—á
    patch = gray_img[y-half_patch:y+half_patch+1,
                     x-half_patch:x+half_patch+1].astype(np.float32)

    # –û–±—á–∏—Å–ª—é—î–º–æ –º–æ–º–µ–Ω—Ç–∏
    m10 = m01 = 0.0
    for i in range(patch.shape[0]):
        for j in range(patch.shape[1]):
            m10 += (j - half_patch) * patch[i, j]
            m01 += (i - half_patch) * patch[i, j]

    return np.arctan2(m01, m10)
```

**–ì–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∞ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è**:

```
        ‚Üë y
        |
    ‚ïî‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïó
    ‚ïë   ‚îÇ   ‚ïë
    ‚ïë   ‚óè‚îÄ‚îÄ‚îÄ‚Üí (m‚ÇÅ‚ÇÄ, m‚ÇÄ‚ÇÅ)
    ‚ïë   ‚îÇ   ‚ïë    ‚Üò Œ∏
    ‚ïö‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïù
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí x
    —Ü–µ–Ω—Ç—Ä  —Ü–µ–Ω—Ç—Ä–æ—ó–¥
```

---

### 4. BRIEF (Binary Robust Independent Elementary Features)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ –±—ñ–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ —à–ª—è—Ö–æ–º –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–µ–π –ø–∞—Ä –ø—ñ–∫—Å–µ–ª—ñ–≤.

**–û—Å–Ω–æ–≤–Ω–∞ —ñ–¥–µ—è**:

```
–î–ª—è N —Ç–µ—Å—Ç–æ–≤–∏—Ö –ø–∞—Ä —Ç–æ—á–æ–∫ (p‚ÇÅ, q‚ÇÅ), (p‚ÇÇ, q‚ÇÇ), ..., (p‚Çô, q‚Çô):

œÑ(patch; p·µ¢, q·µ¢) = {
    1, —è–∫—â–æ I(p·µ¢) < I(q·µ¢)
    0, —ñ–Ω–∞–∫—à–µ
}

–î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä = [œÑ‚ÇÅ, œÑ‚ÇÇ, ..., œÑ‚Çô] - –±—ñ–Ω–∞—Ä–Ω–∏–π –≤–µ–∫—Ç–æ—Ä –¥–æ–≤–∂–∏–Ω–∏ N
```

**–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –≤–µ—Ä—Å—ñ—è BRIEF**:

- N = 256 —Ç–µ—Å—Ç—ñ–≤ ‚Üí 256-–±—ñ—Ç–æ–≤–∏–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä (32 –±–∞–π—Ç–∏)
- –¢–µ—Å—Ç–æ–≤—ñ —Ç–æ—á–∫–∏ –≥–µ–Ω–µ—Ä—É—é—Ç—å—Å—è –≤–∏–ø–∞–¥–∫–æ–≤–æ –æ–¥–∏–Ω —Ä–∞–∑
- –†–æ–∑–ø–æ–¥—ñ–ª —Ç–æ—á–æ–∫: –∑–∞–∑–≤–∏—á–∞–π Gaussian –Ω–∞–≤–∫–æ–ª–æ —Ü–µ–Ω—Ç—Ä—É

**Rotated BRIEF (rBRIEF)** - –¥–ª—è rotation invariance:

```
1. –û–±—á–∏—Å–ª—é—î–º–æ –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é –ø–∞—Ç—á—É Œ∏
2. –û–±–µ—Ä—Ç–∞—î–º–æ —Ç–µ—Å—Ç–æ–≤—ñ —Ç–æ—á–∫–∏ –Ω–∞ -Œ∏:

   [x'] = [cos Œ∏  -sin Œ∏] [x]
   [y']   [sin Œ∏   cos Œ∏] [y]

3. –û–±—á–∏—Å–ª—é—î–º–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –Ω–∞ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Ö —Ç–æ—á–∫–∞—Ö
```

**–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Ñ–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è**:

```
Rotation matrix R(Œ∏):
R(Œ∏) = [cos Œ∏  -sin Œ∏]
       [sin Œ∏   cos Œ∏]

–î–ª—è —Ç–µ—Å—Ç–æ–≤–æ—ó –ø–∞—Ä–∏ (p, q):
p' = R(-Œ∏) √ó p
q' = R(-Œ∏) √ó q

–û–±–µ—Ä—Ç–æ–≤–æ-—ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–Ω–∏–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä:
d = Œ£ 2^i √ó œÑ(patch; R(-Œ∏)p·µ¢, R(-Œ∏)q·µ¢)
    i=0
```

**–£ –∫–æ–¥—ñ**:

```python
def compute_descriptor(self, gray_img, keypoint, angle):
    # –û–±–µ—Ä—Ç–∞–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–∏—Ö —Ç–æ—á–æ–∫
    cos_a, sin_a = np.cos(angle), np.sin(angle)
    rotated = np.zeros_like(self.test_points, dtype=np.int32)

    # Rotation matrix application
    rotated[:, 0] = cos_a * self.test_points[:, 0] - sin_a * self.test_points[:, 1]
    rotated[:, 1] = sin_a * self.test_points[:, 0] + cos_a * self.test_points[:, 1]
    rotated[:, 2] = cos_a * self.test_points[:, 2] - sin_a * self.test_points[:, 3]
    rotated[:, 3] = sin_a * self.test_points[:, 2] + cos_a * self.test_points[:, 3]

    # –û–±—á–∏—Å–ª–µ–Ω–Ω—è –±—ñ–Ω–∞—Ä–Ω–∏—Ö —Ç–µ—Å—Ç—ñ–≤
    descriptor = np.zeros(self.n_tests, dtype=np.uint8)
    for i, (x1, y1, x2, y2) in enumerate(rotated):
        px1, py1 = y + y1, x + x1
        px2, py2 = y + y2, x + x2

        if (0 <= px1 < gray_img.shape[0] and 0 <= py1 < gray_img.shape[1] and
            0 <= px2 < gray_img.shape[0] and 0 <= py2 < gray_img.shape[1]):
            descriptor[i] = 1 if gray_img[px1, py1] < gray_img[px2, py2] else 0

    return descriptor
```

**–ü–µ—Ä–µ–≤–∞–≥–∏ BRIEF**:

- ‚ö° –î—É–∂–µ —à–≤–∏–¥–∫–∏–π (—Ç—ñ–ª—å–∫–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–µ–π)
- üíæ –ö–æ–º–ø–∞–∫—Ç–Ω–∏–π (256 –±—ñ—Ç = 32 –±–∞–π—Ç–∏)
- üî¢ –®–≤–∏–¥–∫–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —á–µ—Ä–µ–∑ Hamming distance

---

### 5. Hamming Distance

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ–∑–∏—Ü—ñ–π, –Ω–∞ —è–∫–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ –±—ñ—Ç–∏ –¥–≤–æ—Ö –±—ñ–Ω–∞—Ä–Ω–∏—Ö –≤–µ–∫—Ç–æ—Ä—ñ–≤ –≤—ñ–¥—Ä—ñ–∑–Ω—è—é—Ç—å—Å—è.

**–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Ñ–æ—Ä–º—É–ª–∞**:

```
–î–ª—è –¥–≤–æ—Ö –±—ñ–Ω–∞—Ä–Ω–∏—Ö –≤–µ–∫—Ç–æ—Ä—ñ–≤ a, b –¥–æ–≤–∂–∏–Ω–∏ n:

d_H(a, b) = Œ£ (a·µ¢ ‚äï b·µ¢)
            i=1

–¥–µ ‚äï - –æ–ø–µ—Ä–∞—Ü—ñ—è XOR (exclusive OR)
```

**–ï—Ñ–µ–∫—Ç–∏–≤–Ω–µ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è**:

```
d_H(a, b) = popcount(a ‚äï b)

–¥–µ popcount - –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–∏–Ω–∏—Ü—å –≤ –±—ñ–Ω–∞—Ä–Ω–æ–º—É –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ñ
```

**–ü—Ä–∏–∫–ª–∞–¥**:

```
a = 10110011
b = 11010001
    ‚Üì‚Üì  ‚Üì

a ‚äï b = 01100010  ‚Üí popcount = 3
d_H(a, b) = 3
```

**–£ –∫–æ–¥—ñ**:

```python
def hamming_distance(self, desc1, desc2):
    return np.count_nonzero(desc1 != desc2)
```

**–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ**:

- –ú–µ—Ç—Ä–∏–∫–∞ (–∑–∞–¥–æ–≤–æ–ª—å–Ω—è—î –∞–∫—Å—ñ–æ–º–∏ –º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É)
- d_H(a, b) ‚â• 0
- d_H(a, b) = 0 ‚ü∫ a = b
- d_H(a, b) = d_H(b, a)
- d_H(a, c) ‚â§ d_H(a, b) + d_H(b, c) (–Ω–µ—Ä—ñ–≤–Ω—ñ—Å—Ç—å —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∞)

---

### 6. Multi-Index Hashing –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ KNN Matching

**–ü—Ä–æ–±–ª–µ–º–∞ brute-force –ø—ñ–¥—Ö–æ–¥—É**:

- –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å: O(n‚ÇÅ √ó n‚ÇÇ √ó d) –¥–µ n‚ÇÅ, n‚ÇÇ - –∫—ñ–ª—å–∫—ñ—Å—Ç—å –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤, d = 256 –±—ñ—Ç
- –î–ª—è 1000√ó1000 –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤: 1,000,000 –æ–±—á–∏—Å–ª–µ–Ω—å Hamming distance
- –ü–æ–≤—ñ–ª—å–Ω–æ –¥–ª—è real-time –∑–∞—Å—Ç–æ—Å—É–Ω–∫—ñ–≤

**–†—ñ—à–µ–Ω–Ω—è: Locality Sensitive Hashing (LSH)**

–Ü–¥–µ—è: —Å—Ö–æ–∂—ñ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏ –º–∞—é—Ç—å –ø–æ—Ç—Ä–∞–ø–ª—è—Ç–∏ –≤ –æ–¥–Ω—ñ bucket —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ñ.

#### –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ Multi-Index Hashing

**1. –•–µ—à-—Ñ—É–Ω–∫—Ü—ñ—ó**

–î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–∞–±–ª–∏—Ü—ñ t –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ä—ñ–∑–Ω—É —á–∞—Å—Ç–∏–Ω—É –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞:

```
–î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä d = [b‚ÇÄ, b‚ÇÅ, b‚ÇÇ, ..., b‚ÇÇ‚ÇÖ‚ÇÖ]  (256 –±—ñ—Ç)

–•–µ—à –¥–ª—è —Ç–∞–±–ª–∏—Ü—ñ t:
h_t(d) = –±—ñ—Ç–∏[(t√ók) mod 256 : (t√ók + k) mod 256]

–¥–µ k = key_size (–∑–∞–∑–≤–∏—á–∞–π 8 –±—ñ—Ç)

–ü—Ä–∏–∫–ª–∞–¥ –¥–ª—è key_size=8:
- Table 0: h‚ÇÄ(d) = –±—ñ—Ç–∏[0:8]   ‚Üí hash_key = 10110010‚ÇÇ = 178‚ÇÅ‚ÇÄ
- Table 1: h‚ÇÅ(d) = –±—ñ—Ç–∏[8:16]  ‚Üí hash_key = 11010110‚ÇÇ = 214‚ÇÅ‚ÇÄ
- Table 2: h‚ÇÇ(d) = –±—ñ—Ç–∏[16:24] ‚Üí hash_key = 01101001‚ÇÇ = 105‚ÇÅ‚ÇÄ
...
```

**2. –ü–æ–±—É–¥–æ–≤–∞ —ñ–Ω–¥–µ–∫—Å—É**

```
–î–ª—è –∫–æ–∂–Ω–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ d‚ÇÇ‚±º –∑ –Ω–∞–±–æ—Ä—É D‚ÇÇ:
    –î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–∞–±–ª–∏—Ü—ñ t = 0..n_tables-1:
        hash_key = h_t(d‚ÇÇ‚±º)
        hash_tables[t][hash_key].append(j)  # –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —ñ–Ω–¥–µ–∫—Å

–†–µ–∑—É–ª—å—Ç–∞—Ç: n_tables —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—å, –¥–µ –∫–æ–∂–µ–Ω –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –ø—Ä–∏—Å—É—Ç–Ω—ñ–π —É –≤—Å—ñ—Ö —Ç–∞–±–ª–∏—Ü—è—Ö
```

**–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è**:

```
–î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä d‚ÇÇ‚ÇÉ: [1,0,1,1,0,0,1,0,1,1,0,1,0,1,1,0,...]
                       ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   8 —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—å              ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Table 0: {178: [12,23,45]}  ‚îÇ  ‚Üê d‚ÇÇ‚ÇÉ –ø–æ—Ç—Ä–∞–ø–∏–≤ —É bucket 178
    ‚îÇ Table 1: {214: [8,23,67]}   ‚îÇ  ‚Üê d‚ÇÇ‚ÇÉ –ø–æ—Ç—Ä–∞–ø–∏–≤ —É bucket 214
    ‚îÇ Table 2: {105: [23,34,89]}  ‚îÇ  ‚Üê d‚ÇÇ‚ÇÉ –ø–æ—Ç—Ä–∞–ø–∏–≤ —É bucket 105
    ‚îÇ ...                          ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**3. –ü–æ—à—É–∫ KNN**

```
–î–ª—è query –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ d‚ÇÅ·µ¢:
    candidates = ‚àÖ

    –î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–∞–±–ª–∏—Ü—ñ t:
        hash_key = h_t(d‚ÇÅ·µ¢)
        candidates ‚à™= hash_tables[t][hash_key]  # –¥–æ–¥–∞—Ç–∏ –≤—Å—ñ —ñ–Ω–¥–µ–∫—Å–∏ –∑ bucket

        if |candidates| >= max_candidates:
            break  # –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤

    # –¢–æ—á–Ω–µ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –≤—ñ–¥—Å—Ç–∞–Ω–µ–π —Ç—ñ–ª—å–∫–∏ –¥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤
    distances = [d_H(d‚ÇÅ·µ¢, d‚ÇÇ‚±º) for j in candidates]

    # –í–∏–±—ñ—Ä K –Ω–∞–π–±–ª–∏–∂—á–∏—Ö
    k_nearest = argpartition(distances, K)[:K]

    return k_nearest
```

**–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å**:

```
–ü–æ–±—É–¥–æ–≤–∞ —ñ–Ω–¥–µ–∫—Å—É: O(n‚ÇÇ √ó n_tables √ó k) ‚âà O(n‚ÇÇ)  (–æ–¥–∏–Ω —Ä–∞–∑)
–ü–æ—à—É–∫ per query: O(n‚ÇÅ √ó |candidates| √ó d)

–î–µ |candidates| << n‚ÇÇ (—Ç–∏–ø–æ–≤–æ 20-100 –∑–∞–º—ñ—Å—Ç—å 1000)

–ó–∞–≥–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å: O(n‚ÇÅ √ó k √ó log(n‚ÇÇ)) –∑–∞–º—ñ—Å—Ç—å O(n‚ÇÅ √ó n‚ÇÇ)
–ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è: ~10-50x –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –Ω–∞–±–æ—Ä—ñ–≤
```

**4. –û–±—Ä–æ–±–∫–∞ –≤–∏–ø–∞–¥–∫—É –º–∞–ª–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤**

```python
if len(candidates) < min_candidates:
    # –î–æ–¥–∞—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤—ñ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏ –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è recall
    additional = random.choice(range(n‚ÇÇ), min_candidates - len(candidates))
    candidates.extend(additional)
```

–¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î:

- **Precision**: –±—ñ–ª—å—à—ñ—Å—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ —Å—Ö–æ–∂—ñ (—á–µ—Ä–µ–∑ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ñ)
- **Recall**: –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ matches (—á–µ—Ä–µ–∑ –≤–∏–ø–∞–¥–∫–æ–≤—ñ –¥–æ–ø–æ–≤–Ω–µ–Ω–Ω—è)

**–£ –∫–æ–¥—ñ**:

```python
def knn_match_fast(self, desc1, desc2, k=2):
    """Fast approximate KNN using LSH-like approach"""
    # 1. Build hash tables once for desc2
    self.build_hash_tables(desc2)

    matches = []
    for i, d1 in enumerate(desc1):
        # 2. Fast candidate search through hash tables
        candidate_indices = self.get_candidates(d1)  # O(n_tables √ó k)

        # 3. Compute distances only to candidates (vectorized)
        candidates = self.desc2_cache[candidate_indices]
        distances = self.hamming_distance_vectorized(d1, candidates)  # O(|candidates|)

        # 4. Find K nearest among candidates
        k_actual = min(k, len(distances))
        k_nearest_local = np.argpartition(distances, k_actual - 1)[:k_actual]
        k_nearest_local = k_nearest_local[np.argsort(distances[k_nearest_local])]

        # 5. Convert local indices back to global indices
        k_matches = [
            cv2.DMatch(i, int(candidate_indices[j]), float(distances[j]))
            for j in k_nearest_local
        ]
        matches.append(k_matches)

    return matches
```

**–ü—Ä–∏–∫–ª–∞–¥ —Ä–æ–±–æ—Ç–∏**:

```
Query –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä: d‚ÇÅ‚ÇÖ = [1,0,1,1,0,0,1,0,...]

–ö—Ä–æ–∫ 1: –•–µ—à—É–≤–∞–Ω–Ω—è
- Table 0: h‚ÇÄ(d‚ÇÅ‚ÇÖ) = 178 ‚Üí bucket –º—ñ—Å—Ç–∏—Ç—å [12, 23, 45, 89]
- Table 1: h‚ÇÅ(d‚ÇÅ‚ÇÖ) = 214 ‚Üí bucket –º—ñ—Å—Ç–∏—Ç—å [8, 23, 67, 90]
- Table 2: h‚ÇÇ(d‚ÇÅ‚ÇÖ) = 105 ‚Üí bucket –º—ñ—Å—Ç–∏—Ç—å [23, 34, 56, 89]

–ö—Ä–æ–∫ 2: –û–±'—î–¥–Ω–∞–Ω–Ω—è –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤
candidates = {8, 12, 23, 34, 45, 56, 67, 89, 90}  (9 –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ –∑–∞–º—ñ—Å—Ç—å 1000!)

–ö—Ä–æ–∫ 3: –û–±—á–∏—Å–ª–µ–Ω–Ω—è Hamming distance
distances = [15, 8, 3, 12, 18, 25, 14, 9, 7]  (9 –æ–±—á–∏—Å–ª–µ–Ω—å –∑–∞–º—ñ—Å—Ç—å 1000)

–ö—Ä–æ–∫ 4: K=2 –Ω–∞–π–±–ª–∏–∂—á–∏—Ö
sorted: [(23, 3), (90, 7)]  ‚Üê —ñ–Ω–¥–µ–∫—Å 23 –Ω–∞–π–±–ª–∏–∂—á–∏–π (distance=3)

–†–µ–∑—É–ª—å—Ç–∞—Ç: matches = [DMatch(5, 23, 3), DMatch(5, 90, 7)]
```

**–ü–µ—Ä–µ–≤–∞–≥–∏ Multi-Index Hashing**:

- ‚ö° –®–≤–∏–¥–∫—ñ—Å—Ç—å: ~10-50x –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è
- üéØ –¢–æ—á–Ω—ñ—Å—Ç—å: –≤–∏—Å–æ–∫–∏–π recall (~95%) –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö
- üíæ –ü–∞–º'—è—Ç—å: O(n‚ÇÇ √ó n_tables) - –ø—Ä–∏–π–Ω—è—Ç–Ω–æ
- üîÑ –ú–∞—Å—à—Ç–∞–±–æ–≤–∞–Ω—ñ—Å—Ç—å: –¥–æ–±—Ä–µ –ø—Ä–∞—Ü—é—î –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –Ω–∞–±–æ—Ä—ñ–≤

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è**:

```python
CustomMatcher(
    ratio_threshold=0.75,  # Lowe's ratio test
    n_tables=8,           # –ë—ñ–ª—å—à–µ —Ç–∞–±–ª–∏—Ü—å ‚Üí –±—ñ–ª—å—à–µ recall, –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ
    key_size=8            # –†–æ–∑–º—ñ—Ä –∫–ª—é—á–∞: –º–µ–Ω—à–µ ‚Üí –±—ñ–ª—å—à–µ –∫–æ–ª—ñ–∑—ñ–π ‚Üí –±—ñ–ª—å—à–µ –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤
)

–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó:
- n_tables: 6-12 (–±–∞–ª–∞–Ω—Å —à–≤–∏–¥–∫—ñ—Å—Ç—å/—Ç–æ—á–Ω—ñ—Å—Ç—å)
- key_size: 6-10 –±—ñ—Ç (8 –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è 256-–±—ñ—Ç–æ–≤–∏—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤)
- max_candidates: 50-200 (–∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ n‚ÇÇ)
```

---

### 7. Lowe's Ratio Test

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è —Ö–∏–±–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π (ambiguous matches).

**–û—Å–Ω–æ–≤–Ω–∞ —ñ–¥–µ—è –î–µ–π–≤—ñ–¥–∞ –õ–æ—É (2004)**:

```
–Ø–∫—â–æ –Ω–∞–π–±–ª–∏–∂—á–∏–π —Å—É—Å—ñ–¥ –Ω–∞–±–∞–≥–∞—Ç–æ –±–ª–∏–∂—á–∏–π –∑–∞ –¥—Ä—É–≥–æ–≥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ,
—Ç–æ —Ü–µ –Ω–∞–¥—ñ–π–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è.
```

**–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Ñ–æ—Ä–º—É–ª–∞**:

```
–î–ª—è –∫–æ–∂–Ω–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ d·µ¢ –∑ K=2 –Ω–∞–π–±–ª–∏–∂—á–∏–º–∏ —Å—É—Å—ñ–¥–∞–º–∏ (m‚ÇÅ, m‚ÇÇ):

–°–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è –ø—Ä–∏–π–º–∞—î—Ç—å—Å—è —è–∫—â–æ:
    distance(m‚ÇÅ) / distance(m‚ÇÇ) < ratio_threshold

–¥–µ:
- m‚ÇÅ - –Ω–∞–π–±–ª–∏–∂—á–∏–π —Å—É—Å—ñ–¥ (best match)
- m‚ÇÇ - –¥—Ä—É–≥–∏–π –Ω–∞–π–±–ª–∏–∂—á–∏–π —Å—É—Å—ñ–¥ (second best match)
- ratio_threshold ‚àà [0.7, 0.8] - —Ç–∏–ø–æ–≤—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
```

**–Ü–Ω—Ç—É—ó—Ü—ñ—è**:

```
–ù–∞–¥—ñ–π–Ω–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è:    Ambiguous (–Ω–µ–Ω–∞–¥—ñ–π–Ω–µ):

    query                 query
      ‚óè                     ‚óè
      |                    / \
      | d‚ÇÅ << d‚ÇÇ          /d‚ÇÅ \d‚ÇÇ
      |                  /     \
      ‚óè        ‚óè        ‚óè       ‚óè
    match‚ÇÅ   match‚ÇÇ   m‚ÇÅ       m‚ÇÇ

d‚ÇÅ/d‚ÇÇ ‚âà 0.5            d‚ÇÅ/d‚ÇÇ ‚âà 0.95
‚úì –ü–†–ò–ô–ú–ê–Ñ–ú–û            ‚úó –í–Ü–î–ö–ò–î–ê–Ñ–ú–û
```

**–°—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω–µ –æ–±–≥—Ä—É–Ω—Ç—É–≤–∞–Ω–Ω—è**:

```
P(correct|d‚ÇÅ/d‚ÇÇ < 0.8) >> P(correct|d‚ÇÅ/d‚ÇÇ > 0.8)

–ó–∞ –¥–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è–º–∏ Lowe (2004):
- ratio = 0.8: ~90% –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö matches, 5% —Ö–∏–±–Ω–∏—Ö —Å–ø—Ä–∞—Ü—å–æ–≤—É–≤–∞–Ω—å
- ratio = 0.7: ~80% –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö matches, 1% —Ö–∏–±–Ω–∏—Ö —Å–ø—Ä–∞—Ü—å–æ–≤—É–≤–∞–Ω—å
```

**–£ –∫–æ–¥—ñ**:

```python
def match(self, desc1, desc2):
    knn_matches = self.knn_match(desc1, desc2, k=2)
    good_matches = []

    for matches in knn_matches:
        if len(matches) >= 2:
            m, n = matches[0], matches[1]
            if m.distance < self.ratio_threshold * n.distance:
                good_matches.append(m)

    return good_matches
```

**–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è ratio_threshold**:

- 0.7 - —Å—Ç—Ä–æ–≥–∏–π (–º–µ–Ω—à–µ matches, –±—ñ–ª—å—à–µ precision)
- 0.75 - –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∏–π
- 0.8 - –º'—è–∫–∏–π (–±—ñ–ª—å—à–µ matches, –º–µ–Ω—à–µ precision)

---

## –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ —Ñ–æ—Ä–º—É–ª–∏

### –ê—Ñ—ñ–Ω–Ω–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è

**–ó–∞–≥–∞–ª—å–Ω–∞ —Ñ–æ—Ä–º–∞**:

```
[x']   [a  b  tx] [x]
[y'] = [c  d  ty] [y]
[1 ]   [0  0  1 ] [1]

–∞–±–æ –∫–æ–º–ø–∞–∫—Ç–Ω–æ:
[x']   [a  b  tx] [x]
[y'] = [c  d  ty] [y]
                   [1]
```

**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó**:

```
Rotation + Scale:
[a  b] = s √ó [cos Œ∏  -sin Œ∏]
[c  d]       [sin Œ∏   cos Œ∏]

Translation:
[tx]
[ty]
```

**–†–æ–∑–∫–ª–∞–¥–∞–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤**:

```
–ó –º–∞—Ç—Ä–∏—Ü—ñ M = [a  b  tx]
              [c  d  ty]

–ö—É—Ç –ø–æ–≤–æ—Ä–æ—Ç—É:
Œ∏ = atan2(c, a)

–ú–∞—Å—à—Ç–∞–± (–ø—Ä–∏–±–ª–∏–∑–Ω–æ):
s = (‚àö(a¬≤ + c¬≤) + ‚àö(b¬≤ + d¬≤)) / 2

–∞–±–æ —Ç–æ—á–Ω—ñ—à–µ:
s‚Çì = ‚àö(a¬≤ + c¬≤)
s·µß = ‚àö(b¬≤ + d¬≤)
s = (s‚Çì + s·µß) / 2

–ó–º—ñ—â–µ–Ω–Ω—è:
tx = M[0, 2]
ty = M[1, 2]
```

**–£ –∫–æ–¥—ñ**:

```python
def extract_params(self, M):
    tx, ty = M[0, 2], M[1, 2]
    a, b, c, d = M[0, 0], M[0, 1], M[1, 0], M[1, 1]

    angle = np.degrees(np.arctan2(c, a))
    scale = (np.sqrt(a**2 + c**2) + np.sqrt(b**2 + d**2)) / 2

    return {"angle": angle, "tx": tx, "ty": ty, "scale": scale}
```

---

### 8. RANSAC (Random Sample Consensus)

**–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –†–æ–±–∞—Å—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –º–æ–¥–µ–ª—ñ –≤ –ø—Ä–∏—Å—É—Ç–Ω–æ—Å—Ç—ñ outliers (–≤–∏–∫–∏–¥—ñ–≤).

**–û—Å–Ω–æ–≤–Ω–∞ —ñ–¥–µ—è**:

```
–ó–∞–º—ñ—Å—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤—Å—ñ—Ö –¥–∞–Ω–∏—Ö –¥–ª—è –æ—Ü—ñ–Ω–∫–∏ –º–æ–¥–µ–ª—ñ,
–≤–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±–∏—Ä–∞—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –ø—ñ–¥–º–Ω–æ–∂–∏–Ω–∏ —Ç–∞ —à—É–∫–∞—î–º–æ
–º–æ–¥–µ–ª—å –∑ –Ω–∞–π–±—ñ–ª—å—à–æ—é –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é (inliers).
```

#### –î–µ—Ç–∞–ª—å–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º RANSAC

**–ü—Å–µ–≤–¥–æ–∫–æ–¥**:

```
–í—Ö—ñ–¥:
- data = {(x‚ÇÅ, y‚ÇÅ), (x‚ÇÇ, y‚ÇÇ), ..., (x‚Çô, y‚Çô)} - –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ —Ç–æ—á–æ–∫
- threshold t - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è inlier
- max_iterations K - –∫—ñ–ª—å–∫—ñ—Å—Ç—å —ñ—Ç–µ—Ä–∞—Ü—ñ–π
- min_inliers M - –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å inliers

1. best_model ‚Üê None
   best_inliers ‚Üê ‚àÖ
   max_inlier_count ‚Üê 0

2. –ü–æ–≤—Ç–æ—Ä–∏—Ç–∏ K —Ä–∞–∑—ñ–≤:
   a) –í–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±—Ä–∞—Ç–∏ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—É –º–Ω–æ–∂–∏–Ω—É S (–¥–ª—è –∞—Ñ—ñ–Ω–Ω–æ—ó: 3 —Ç–æ—á–∫–∏)

   b) –û—Ü—ñ–Ω–∏—Ç–∏ –º–æ–¥–µ–ª—å Œ∏ –Ω–∞ S:
      Œ∏ = estimate_model(S)

   c) –ó–Ω–∞–π—Ç–∏ –≤—Å—ñ inliers I:
      I = {(x·µ¢, y·µ¢) | distance(transform(x·µ¢, Œ∏), y·µ¢) < t}

   d) –Ø–∫—â–æ |I| > max_inlier_count:
      - –ü–µ—Ä–µ—Ä–∞—Ö—É–≤–∞—Ç–∏ –º–æ–¥–µ–ª—å –Ω–∞ –≤—Å—ñ—Ö inliers:
        Œ∏* = estimate_model(I)
      - best_model ‚Üê Œ∏*
      - best_inliers ‚Üê I
      - max_inlier_count ‚Üê |I|

3. –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ (best_model, best_inliers)
```

#### –î–µ—Ç–∞–ª—å–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ —Ä–æ–±–æ—Ç–∏ RANSAC

**–°—Ü–µ–Ω–∞—Ä—ñ–π**: –ú–∞—î–º–æ 10 –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π —Ç–æ—á–æ–∫, 4 –∑ –Ω–∏—Ö outliers (40% —à—É–º—É).

**–í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ**:

```
Matches (src ‚Üí dst):
1. (100, 50) ‚Üí (120, 70)   ‚úì inlier
2. (150, 80) ‚Üí (170, 100)  ‚úì inlier
3. (200, 120) ‚Üí (220, 140) ‚úì inlier
4. (80, 200) ‚Üí (300, 50)   ‚úó outlier (–ø–æ–º–∏–ª–∫–æ–≤–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è)
5. (250, 150) ‚Üí (270, 170) ‚úì inlier
6. (180, 90) ‚Üí (50, 250)   ‚úó outlier
7. (120, 180) ‚Üí (140, 200) ‚úì inlier
8. (90, 140) ‚Üí (250, 300)  ‚úó outlier
9. (210, 110) ‚Üí (230, 130) ‚úì inlier
10. (160, 200) ‚Üí (10, 10)  ‚úó outlier

–Ü—Å—Ç–∏–Ω–Ω–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è: –æ–±–µ—Ä—Ç–∞–Ω–Ω—è 10¬∞, –∑–º—ñ—â–µ–Ω–Ω—è (20, 20), –º–∞—Å—à—Ç–∞–± 1.0
–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ RANSAC: threshold=5.0, max_iterations=100, min_inliers=4
```

**–Ü—Ç–µ—Ä–∞—Ü—ñ—è 1**:

```
–ö—Ä–æ–∫ 1: –í–∏–ø–∞–¥–∫–æ–≤–∏–π –≤–∏–±—ñ—Ä 3 —Ç–æ—á–æ–∫
    –í–∏–±—Ä–∞–Ω–æ —ñ–Ω–¥–µ–∫—Å–∏: [4, 8, 10]
    –¢–æ—á–∫–∏: (80,200)‚Üí(300,50), (90,140)‚Üí(250,300), (160,200)‚Üí(10,10)

–ö—Ä–æ–∫ 2: –û—Ü—ñ–Ω–∫–∞ –º–æ–¥–µ–ª—ñ (Least Squares –Ω–∞ 3 —Ç–æ—á–∫–∏)
    M‚ÇÅ = [[-0.5  0.8  280]
          [-0.3 -0.4  150]]

–ö—Ä–æ–∫ 3: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤—Å—ñ—Ö —Ç–æ—á–æ–∫
    –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º—É—î–º–æ –∫–æ–∂–Ω—É src —Ç–æ—á–∫—É —á–µ—Ä–µ–∑ M‚ÇÅ —ñ –æ–±—á–∏—Å–ª—é—î–º–æ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ dst:

    Point 1: transform(100,50) = (310, 135) ‚Üí distance to (120,70) = 197.3 ‚úó
    Point 2: transform(150,80) = (344, 112) ‚Üí distance to (170,100) = 174.2 ‚úó
    Point 3: transform(200,120) = (390, 98) ‚Üí distance to (220,140) = 171.5 ‚úó
    Point 4: transform(80,200) = (298, 48) ‚Üí distance to (300,50) = 2.8 ‚úì
    Point 5: transform(250,150) = (430, 75) ‚Üí distance to (270,170) = 174.3 ‚úó
    Point 6: transform(180,90) = (352, 105) ‚Üí distance to (50,250) = 335.9 ‚úó
    Point 7: transform(120,180) = (334, 102) ‚Üí distance to (140,200) = 204.6 ‚úó
    Point 8: transform(90,140) = (302, 83) ‚Üí distance to (250,300) = 219.4 ‚úó
    Point 9: transform(210,110) = (388, 93) ‚Üí distance to (230,130) = 162.3 ‚úó
    Point 10: transform(160,200) = (348, 104) ‚Üí distance to (10,10) = 352.6 ‚úó

    Inliers: 1 (—Ç—ñ–ª—å–∫–∏ Point 4)
    best_inlier_count = 1
```

**–Ü—Ç–µ—Ä–∞—Ü—ñ—è 2**:

```
–ö—Ä–æ–∫ 1: –í–∏–ø–∞–¥–∫–æ–≤–∏–π –≤–∏–±—ñ—Ä 3 —Ç–æ—á–æ–∫
    –í–∏–±—Ä–∞–Ω–æ —ñ–Ω–¥–µ–∫—Å–∏: [1, 3, 9]
    –¢–æ—á–∫–∏: (100,50)‚Üí(120,70), (200,120)‚Üí(220,140), (210,110)‚Üí(230,130)

–ö—Ä–æ–∫ 2: –û—Ü—ñ–Ω–∫–∞ –º–æ–¥–µ–ª—ñ
    M‚ÇÇ = [[0.98 -0.17  20.5]
          [0.17  0.98  19.8]]
    (–æ–±–µ—Ä—Ç–∞–Ω–Ω—è ‚âà10¬∞, –∑–º—ñ—â–µ–Ω–Ω—è ‚âà(20,20), –º–∞—Å—à—Ç–∞–± ‚âà1.0)

–ö—Ä–æ–∫ 3: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤—Å—ñ—Ö —Ç–æ—á–æ–∫
    Point 1: transform(100,50) = (119.5, 70.2) ‚Üí distance to (120,70) = 0.5 ‚úì
    Point 2: transform(150,80) = (169.4, 99.8) ‚Üí distance to (170,100) = 0.6 ‚úì
    Point 3: transform(200,120) = (219.5, 139.7) ‚Üí distance to (220,140) = 0.5 ‚úì
    Point 4: transform(80,200) = (99.8, 219.5) ‚Üí distance to (300,50) = 254.8 ‚úó
    Point 5: transform(250,150) = (269.4, 169.9) ‚Üí distance to (270,170) = 0.6 ‚úì
    Point 6: transform(180,90) = (199.2, 109.5) ‚Üí distance to (50,250) = 201.7 ‚úó
    Point 7: transform(120,180) = (139.8, 199.6) ‚Üí distance to (140,200) = 0.4 ‚úì
    Point 8: transform(90,140) = (109.7, 159.4) ‚Üí distance to (250,300) = 195.3 ‚úó
    Point 9: transform(210,110) = (229.6, 129.8) ‚Üí distance to (230,130) = 0.4 ‚úì
    Point 10: transform(160,200) = (179.5, 219.7) ‚Üí distance to (10,10) = 287.5 ‚úó

    Inliers: 6 (Points: 1,2,3,5,7,9) ‚úì‚úì‚úì

–ö—Ä–æ–∫ 4: –û–Ω–æ–≤–ª–µ–Ω–Ω—è best_model
    6 > 1, —Ç–æ–º—É –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ –º–æ–¥–µ–ª—å –Ω–∞ –≤—Å—ñ—Ö 6 inliers

    M‚ÇÇ_refined = least_squares([Point1, Point2, Point3, Point5, Point7, Point9])
               = [[0.985 -0.174  20.1]
                  [0.174  0.985  19.9]]

    best_model = M‚ÇÇ_refined
    best_inliers = {1,2,3,5,7,9}
    max_inlier_count = 6
```

**–Ü—Ç–µ—Ä–∞—Ü—ñ—è 3-100**:

```
–ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó, –∞–ª–µ –∑–Ω–∞–π—Ç–∏ –∫—Ä–∞—â–µ –∑–∞ 6 inliers –Ω–µ –≤–¥–∞—î—Ç—å—Å—è.
–Ü–Ω–æ–¥—ñ –æ—Ç—Ä–∏–º—É—î–º–æ 5 inliers, —ñ–Ω–æ–¥—ñ 3-4, –∞–ª–µ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –ø–µ—Ä–µ–≤–∏—â—É—î–º–æ 6.
```

**–§—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç**:

```
best_model = [[0.985 -0.174  20.1]
              [0.174  0.985  19.9]]

–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó:
- –ö—É—Ç: Œ∏ = atan2(0.174, 0.985) = 10.0¬∞  ‚úì (—Ç–æ—á–Ω–æ!)
- –ó–º—ñ—â–µ–Ω–Ω—è: (20.1, 19.9)  ‚úì (–º–∞–π–∂–µ —Ç–æ—á–Ω–æ –¥–æ (20,20))
- –ú–∞—Å—à—Ç–∞–±: ‚àö(0.985¬≤ + 0.174¬≤) ‚âà 1.00  ‚úì (—Ç–æ—á–Ω–æ!)

Inliers: 6/10 = 60%  ‚úì (–ø—Ä–∞–≤–∏–ª—å–Ω–æ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–æ–≤–∞–Ω–æ –≤—Å—ñ 6 –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö matches)
Outliers: 4/10 = 40% ‚úì (–≤—Å—ñ 4 –ø–æ–º–∏–ª–∫–æ–≤—ñ –≤—ñ–¥–∫–∏–Ω—É—Ç—ñ)
```

**–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è**:

```
–ü–æ—á–∞—Ç–∫–æ–≤—ñ matches:           –ü—ñ—Å–ª—è RANSAC:

    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄX                     ‚óè       X ‚úó (–≤—ñ–¥–∫–∏–Ω—É—Ç–æ)
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄX                     ‚óè       X ‚úó (–≤—ñ–¥–∫–∏–Ω—É—Ç–æ)
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óè‚îÄX                         ‚óè       X ‚úó (–≤—ñ–¥–∫–∏–Ω—É—Ç–æ)
    ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè                   ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè ‚úì
    ‚óèX                          ‚óè       X ‚úó (–≤—ñ–¥–∫–∏–Ω—É—Ç–æ)

10 matches                  6 inliers + 4 outliers
(–º—ñ—Å—Ç—è—Ç—å —à—É–º)              (–æ—á–∏—â–µ–Ω—ñ –¥–∞–Ω—ñ)
```

#### –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ —Ñ–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è

**–ú–æ–¥–µ–ª—å –∞—Ñ—ñ–Ω–Ω–æ—ó —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó**:

```
[x'] = [a  b  tx] [x]
[y']   [c  d  ty] [y]
                   [1]

–ü–∞—Ä–∞–º–µ—Ç—Ä–∏: Œ∏ = [a, b, tx, c, d, ty]
–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –º–Ω–æ–∂–∏–Ω–∞: 3 —Ç–æ—á–∫–∏ (6 —Ä—ñ–≤–Ω—è–Ω—å, 6 –Ω–µ–≤—ñ–¥–æ–º–∏—Ö)
```

**Residual (–∑–∞–ª–∏—à–æ–∫)**:

```
–î–ª—è —Ç–æ—á–∫–∏ (x·µ¢, y·µ¢) ‚Üí (x'·µ¢, y'·µ¢):

–ü–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ:
[xÃÇ·µ¢] = M ¬∑ [x·µ¢]
[≈∑·µ¢]       [y·µ¢]
           [1]

Residual:
r·µ¢ = ‚àö[(xÃÇ·µ¢ - x'·µ¢)¬≤ + (≈∑·µ¢ - y'·µ¢)¬≤]

Inlier —è–∫—â–æ: r·µ¢ < threshold
```

**–í—ñ—Ä–æ–≥—ñ–¥–Ω—ñ—Å—Ç—å —É—Å–ø—ñ—Ö—É**:

```
–ù–µ—Ö–∞–π w = —á–∞—Å—Ç–∫–∞ inliers —Å–µ—Ä–µ–¥ —É—Å—ñ—Ö matches
–î–ª—è –∞—Ñ—ñ–Ω–Ω–æ—ó –ø–æ—Ç—Ä—ñ–±–Ω–æ n=3 —Ç–æ—á–∫–∏

–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –≤–∏–±—Ä–∞—Ç–∏ 3 inliers –∑–∞ –æ–¥–Ω—É —ñ—Ç–µ—Ä–∞—Ü—ñ—é:
p‚ÇÅ = w¬≥

–ü—Ä–∏–∫–ª–∞–¥: w=0.6 (60% inliers) ‚Üí p‚ÇÅ = 0.6¬≥ = 0.216 = 21.6%

–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –ù–ï –∑–Ω–∞–π—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É –º–æ–¥–µ–ª—å –∑–∞ K —ñ—Ç–µ—Ä–∞—Ü—ñ–π:
p_fail = (1 - w¬≥)·¥∑

–ô–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å —É—Å–ø—ñ—Ö—É:
P(success) = 1 - (1 - w¬≥)·¥∑

–î–ª—è –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ–≥–æ —É—Å–ø—ñ—Ö—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 99%):
0.99 = 1 - (1 - w¬≥)·¥∑
K = log(0.01) / log(1 - w¬≥)

–ü—Ä–∏–∫–ª–∞–¥ –¥–ª—è w=0.6, P=0.99:
K = log(0.01) / log(0.784) ‚âà 19 —ñ—Ç–µ—Ä–∞—Ü—ñ–π

–î–ª—è w=0.4 (40% inliers):
K = log(0.01) / log(0.936) ‚âà 70 —ñ—Ç–µ—Ä–∞—Ü—ñ–π
```

**–£ –∫–æ–¥—ñ**:

```python
def find_transform(self, src_pts, dst_pts):
    if len(src_pts) < 3:
        return None, None, None

    best_M = None
    best_inlier_mask = None
    max_inlier_count = 0

    for iteration in range(self.max_iterations):
        # 1. Random sample
        indices = np.random.choice(len(src_pts), 3, replace=False)
        M = self.estimate_affine_transform(src_pts[indices], dst_pts[indices])

        if M is None:
            continue

        # 2. Count inliers
        inliers, inlier_mask = self.count_inliers(src_pts, dst_pts, M)

        # 3. Update best model
        if len(inliers) > max_inlier_count:
            max_inlier_count = len(inliers)
            best_inlier_mask = inlier_mask

            # 4. Refine on all inliers
            if len(inliers) >= self.min_inliers:
                M_refined = self.estimate_affine_transform(
                    src_pts[inliers], dst_pts[inliers]
                )
                if M_refined is not None:
                    best_M = M_refined

    if best_M is not None:
        params = self.extract_params(best_M)
        params.update({
            "inliers": max_inlier_count,
            "total_matches": len(src_pts),
            "inlier_ratio": max_inlier_count / len(src_pts)
        })
        return best_M, best_inlier_mask, params

    return None, None, None
```

**–ö–ª—é—á–æ–≤—ñ –º–æ–º–µ–Ω—Ç–∏**:

1. **–í–∏–ø–∞–¥–∫–æ–≤—ñ—Å—Ç—å**: –∫–æ–∂–Ω–∞ —ñ—Ç–µ—Ä–∞—Ü—ñ—è –≤–∏–±–∏—Ä–∞—î —Ä—ñ–∑–Ω—ñ 3 —Ç–æ—á–∫–∏
2. **Consensus**: –º–æ–¥–µ–ª—å –æ—Ü—ñ–Ω—é—î—Ç—å—Å—è –Ω–∞ –≤—Å—ñ—Ö –¥–∞–Ω–∏—Ö, –Ω–µ —Ç—ñ–ª—å–∫–∏ –Ω–∞ –≤–∏–±—ñ—Ä—Ü—ñ
3. **Refinement**: —Ñ—ñ–Ω–∞–ª—å–Ω–∞ –º–æ–¥–µ–ª—å –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è –Ω–∞ –≤—Å—ñ—Ö inliers –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç—ñ
4. **Threshold**: –∫—Ä–∏—Ç–∏—á–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä - –∑–∞–Ω–∞–¥—Ç–æ –º–∞–ª–∏–π ‚Üí –º–∞–ª–æ inliers, –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–∏–π ‚Üí outliers —Å—Ç–∞—é—Ç—å inliers

**–ü–µ—Ä–µ–≤–∞–≥–∏ RANSAC**:

- ‚úÖ –†–æ–±–∞—Å—Ç–Ω–∏–π –¥–æ outliers (–¥–æ 50% –≤–∏–∫–∏–¥—ñ–≤)
- ‚úÖ –ü—Ä–æ—Å—Ç–∏–π —É —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó
- ‚úÖ –£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π (–ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö –º–æ–¥–µ–ª–µ–π)
- ‚úÖ –ù–µ –ø–æ—Ç—Ä–µ–±—É—î –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ —à—É–º

**–ù–µ–¥–æ–ª—ñ–∫–∏ RANSAC**:

- ‚ùå –ù–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–π (—Ä—ñ–∑–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø—Ä–∏ —Ä—ñ–∑–Ω–∏—Ö –∑–∞–ø—É—Å–∫–∞—Ö)
- ‚ùå –ü–æ—Ç—Ä–µ–±—É—î –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ (threshold, iterations)
- ‚ùå –ü–æ–≤—ñ–ª—å–Ω–∏–π –ø—Ä–∏ –≤–µ–ª–∏–∫—ñ–π –∫—ñ–ª—å–∫–æ—Å—Ç—ñ outliers (–ø–æ—Ç—Ä—ñ–±–Ω–æ –±—ñ–ª—å—à–µ —ñ—Ç–µ—Ä–∞—Ü—ñ–π)
- ‚ùå –ù–µ –≥–∞—Ä–∞–Ω—Ç—É—î –æ–ø—Ç–∏–º–∞–ª—å–Ω–µ —Ä—ñ—à–µ–Ω–Ω—è (—Ç—ñ–ª—å–∫–∏ "–¥–æ—Å–∏—Ç—å –¥–æ–±—Ä–µ")

**–ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ RANSAC**:

- üéØ –Ñ outliers —É –¥–∞–Ω–∏—Ö (–ø–æ–º–∏–ª–∫–æ–≤—ñ matches)
- üéØ –í—ñ–¥–æ–º–∞ –º–æ–¥–µ–ª—å (–∞—Ñ—ñ–Ω–Ω–∞, –≥–æ–º–æ–≥—Ä–∞—Ñ—ñ—è, –ø—Ä—è–º–∞ –ª—ñ–Ω—ñ—è)
- üéØ –ú–æ–∂–Ω–∞ —à–≤–∏–¥–∫–æ –æ—Ü—ñ–Ω–∏—Ç–∏ –º–æ–¥–µ–ª—å –Ω–∞ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ–π –º–Ω–æ–∂–∏–Ω—ñ
- üéØ –ú–æ–∂–Ω–∞ —à–≤–∏–¥–∫–æ –æ–±—á–∏—Å–ª–∏—Ç–∏ residual –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ inliers

---

### 9. Least Squares –¥–ª—è –ê—Ñ—ñ–Ω–Ω–æ—ó –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó

**–ó–∞–¥–∞—á–∞**: –ó–Ω–∞–π—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∞—Ñ—ñ–Ω–Ω–æ—ó —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó, —â–æ –º—ñ–Ω—ñ–º—ñ–∑—É—é—Ç—å –ø–æ—Ö–∏–±–∫—É.

**–ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–¥–∞—á—ñ**:

```
–î–∞–Ω–æ: N –ø–∞—Ä —Ç–æ—á–æ–∫ {(x·µ¢, y·µ¢) ‚Üí (x'·µ¢, y'·µ¢)}·µ¢‚Çå‚ÇÅ·¥∫
–ó–Ω–∞–π—Ç–∏: M = [a  b  tx]
            [c  d  ty]

—â–æ –º—ñ–Ω—ñ–º—ñ–∑—É—î:
E = Œ£ ||M¬∑[x·µ¢, y·µ¢, 1]·µÄ - [x'·µ¢, y'·µ¢]·µÄ||¬≤
    i=1
```

**–õ—ñ–Ω–µ–∞—Ä–∏–∑–∞—Ü—ñ—è**:

```
–î–ª—è –∫–æ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ (x·µ¢, y·µ¢) ‚Üí (x'·µ¢, y'·µ¢):

x'·µ¢ = a¬∑x·µ¢ + b¬∑y·µ¢ + tx
y'·µ¢ = c¬∑x·µ¢ + d¬∑y·µ¢ + ty

–ú–∞—Ç—Ä–∏—á–Ω–∞ —Ñ–æ—Ä–º–∞ –¥–ª—è N —Ç–æ—á–æ–∫:
[x‚ÇÅ  y‚ÇÅ  1  0   0   0 ] [a ]   [x'‚ÇÅ]
[0   0   0  x‚ÇÅ  y‚ÇÅ  1 ] [b ]   [y'‚ÇÅ]
[x‚ÇÇ  y‚ÇÇ  1  0   0   0 ] [tx] = [x'‚ÇÇ]
[0   0   0  x‚ÇÇ  y‚ÇÇ  1 ] [c ]   [y'‚ÇÇ]
[...                  ] [d ]   [...]
[x‚Çô  y‚Çô  1  0   0   0 ] [ty]   [x'‚Çô]
[0   0   0  x‚Çô  y‚Çô  1 ]        [y'‚Çô]

–ê–±–æ: A¬∑Œ∏ = b
```

**–†–æ–∑–≤'—è–∑–æ–∫ –º–µ—Ç–æ–¥–æ–º –Ω–∞–π–º–µ–Ω—à–∏—Ö –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤**:

```
–ù–æ—Ä–º–∞–ª—å–Ω–µ —Ä—ñ–≤–Ω—è–Ω–Ω—è:
A·µÄA¬∑Œ∏ = A·µÄb

–†–æ–∑–≤'—è–∑–æ–∫:
Œ∏ = (A·µÄA)‚Åª¬π¬∑A·µÄb

–∞–±–æ —á–µ—Ä–µ–∑ –ø—Å–µ–≤–¥–æ–æ–±–µ—Ä–Ω–µ–Ω—É –º–∞—Ç—Ä–∏—Ü—é:
Œ∏ = A‚Å∫¬∑b = (A·µÄA)‚Åª¬π¬∑A·µÄ¬∑b
```

**–£–º–æ–≤–∏ –∫–æ—Ä–µ–∫—Ç–Ω–æ—Å—Ç—ñ**:

```
–î–ª—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ–≥–æ —Ä–æ–∑–≤'—è–∑–∫—É –ø–æ—Ç—Ä—ñ–±–Ω–æ:
1. N ‚â• 3 (–º—ñ–Ω—ñ–º—É–º 3 —Ç–æ—á–∫–∏)
2. –¢–æ—á–∫–∏ –Ω–µ –∫–æ–ª—ñ–Ω–µ–∞—Ä–Ω—ñ (–Ω–µ –Ω–∞ –æ–¥–Ω—ñ–π –ø—Ä—è–º—ñ–π)
3. rank(A) = 6 (–ø–æ–≤–Ω–∏–π —Ä–∞–Ω–≥)
```

**–ü–æ—Ö–∏–±–∫–∞ –æ—Ü—ñ–Ω–∫–∏**:

```
–ó–∞–ª–∏—à–∫–æ–≤–∞ –ø–æ—Ö–∏–±–∫–∞ (residual):
r·µ¢ = ||M¬∑[x·µ¢, y·µ¢, 1]·µÄ - [x'·µ¢, y'·µ¢]·µÄ||

RMS (Root Mean Square) error:
RMSE = ‚àö(1/N ¬∑ Œ£r·µ¢¬≤)
         i=1
```

**–£ –∫–æ–¥—ñ**:

```python
def estimate_affine_transform(self, src_pts, dst_pts):
    if len(src_pts) < 3:
        return None

    A = []
    b = []
    for (x, y), (x_prime, y_prime) in zip(src_pts, dst_pts):
        # –†—ñ–≤–Ω—è–Ω–Ω—è –¥–ª—è x'
        A.append([x, y, 1, 0, 0, 0])
        b.append(x_prime)
        # –†—ñ–≤–Ω—è–Ω–Ω—è –¥–ª—è y'
        A.append([0, 0, 0, x, y, 1])
        b.append(y_prime)

    try:
        # –†–æ–∑–≤'—è–∑–∞–Ω–Ω—è —á–µ—Ä–µ–∑ lstsq (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î SVD)
        params = np.linalg.lstsq(np.array(A), np.array(b), rcond=None)[0]
        return np.array([
            [params[0], params[1], params[2]],
            [params[3], params[4], params[5]]
        ])
    except:
        return None
```

---

## –ê–Ω–∞–ª—ñ–∑ –∫–æ–¥—É

### –ú–æ–∂–ª–∏–≤—ñ –ø–æ–º–∏–ª–∫–∏ —Ç–∞ –≤—Ä–∞–∑–ª–∏–≤–æ—Å—Ç—ñ

#### 1. **–û–±—Ä–æ–±–∫–∞ –≥—Ä–∞–Ω–∏—á–Ω–∏—Ö –≤–∏–ø–∞–¥–∫—ñ–≤**

**–ü—Ä–æ–±–ª–µ–º–∞ –≤ `detect_keypoints`**:

```python
# –ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞: —è–∫—â–æ —Ä—ñ–≤–µ–Ω—å –ø—ñ—Ä–∞–º—ñ–¥–∏ —Å—Ç–∞—î –∑–∞–Ω–∞–¥—Ç–æ –º–∞–ª–∏–º
if new_size[0] < self.patch_size or new_size[1] < self.patch_size:
    break
```

‚úÖ **–î–æ–±—Ä–µ**: —î –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–æ–∑–º—ñ—Ä—É

**–ü—Ä–æ–±–ª–µ–º–∞ –≤ `compute_orientation`**:

```python
if (y - half_patch < 0 or y + half_patch >= gray_img.shape[0] or
    x - half_patch < 0 or x + half_patch >= gray_img.shape[1]):
    return 0.0
```

‚ùå **–ü—Ä–æ–±–ª–µ–º–∞**: –ø–æ–≤–µ—Ä—Ç–∞—î 0.0 –∑–∞–º—ñ—Å—Ç—å None - –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –Ω–µ–≤–∞–ª—ñ–¥–Ω–æ—ó –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó

**–í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è**:

```python
# –ö—Ä–∞—â–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ None —ñ –æ–±—Ä–æ–±–∏—Ç–∏ —Ü–µ –≤ detectAndCompute
if –Ω–µ_–≤_–º–µ–∂–∞—Ö:
    return None
```

#### 2. **–ï—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –æ–±—á–∏—Å–ª–µ–Ω—å**

**–ü—Ä–æ–±–ª–µ–º–∞ –≤ `compute_orientation`**:

```python
# –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –ø–æ–¥–≤—ñ–π–Ω–∏–π —Ü–∏–∫–ª Python
for i in range(patch.shape[0]):
    for j in range(patch.shape[1]):
        m10 += (j - half_patch) * patch[i, j]
        m01 += (i - half_patch) * patch[i, j]
```

‚ùå **–ü–æ–≤—ñ–ª—å–Ω–æ**: Python loops O(n¬≤)

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è**:

```python
# –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è —á–µ—Ä–µ–∑ NumPy
y_coords, x_coords = np.ogrid[-half_patch:half_patch+1, -half_patch:half_patch+1]
m10 = np.sum(x_coords * patch)
m01 = np.sum(y_coords * patch)
```

‚úÖ **–®–≤–∏–¥—à–µ**: ~10-50x –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è

#### 3. **–û–±—Ä–æ–±–∫–∞ –ø–æ–º–∏–ª–æ–∫ —É RANSAC**

**–ü—Ä–æ–±–ª–µ–º–∞**:

```python
try:
    params = np.linalg.lstsq(np.array(A), np.array(b), rcond=None)[0]
    return np.array([[params[0], params[1], params[2]],
                     [params[3], params[4], params[5]]])
except:
    return None
```

‚ùå **–ó–∞–Ω–∞–¥—Ç–æ —à–∏—Ä–æ–∫–∏–π except**: –ª–æ–≤–∏—Ç—å —É—Å—ñ –ø–æ–º–∏–ª–∫–∏

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è**:

```python
try:
    params = np.linalg.lstsq(np.array(A), np.array(b), rcond=None)[0]
    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –≤–∏—Ä–æ–¥–∂–µ–Ω—É –º–∞—Ç—Ä–∏—Ü—é
    if np.any(np.isnan(params)) or np.any(np.isinf(params)):
        return None
    return np.array([[params[0], params[1], params[2]],
                     [params[3], params[4], params[5]]])
except (np.linalg.LinAlgError, ValueError) as e:
    print(f"Failed to estimate transform: {e}")
    return None
```

#### 4. **–ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞ –∑ –ø–∞–º'—è—Ç—Ç—é**

**–£ `knn_match`**:

```python
distances = np.array([self.hamming_distance(d1, d2) for d2 in desc2])
```

‚ùå **–ü—Ä–æ–±–ª–µ–º–∞**: –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–æ–≤–∏–π –º–∞—Å–∏–≤

- –Ø–∫—â–æ 1000 keypoints √ó 1000 comparisons = 1M –æ–±—á–∏—Å–ª–µ–Ω—å

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è —á–µ—Ä–µ–∑ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—é**:

```python
# –í–µ–∫—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–µ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è Hamming distance
def hamming_distance_batch(self, desc1, desc2_array):
    """–û–±—á–∏—Å–ª–∏—Ç–∏ –≤—ñ–¥—Å—Ç–∞–Ω—ñ –≤—ñ–¥ desc1 –¥–æ –≤—Å—ñ—Ö desc2"""
    return np.count_nonzero(desc1 != desc2_array, axis=1)

def knn_match(self, desc1, desc2, k=2):
    matches = []
    for i, d1 in enumerate(desc1):
        distances = self.hamming_distance_batch(d1, desc2)
        # ... —Ä–µ—à—Ç–∞ –∫–æ–¥—É
```

#### 5. **–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —É –ø—ñ—Ä–∞–º—ñ–¥—ñ**

**–ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∞ –Ω–µ—Ç–æ—á–Ω—ñ—Å—Ç—å**:

```python
scale = self.scale_factor ** level
for kp in kps:
    kp.pt = (kp.pt[0] * scale, kp.pt[1] * scale)
```

‚úÖ **–ü—Ä–∞—Ü—é—î**, –∞–ª–µ –º–æ–∂–Ω–∞ –ø–æ–∫—Ä–∞—â–∏—Ç–∏ —Ç–æ—á–Ω—ñ—Å—Ç—å:

```python
# –ó–±–µ—Ä—ñ–≥–∞—Ç–∏ —Ç–æ—á–Ω–∏–π –º–∞—Å—à—Ç–∞–± –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è
kp.pt = (kp.pt[0] * scale, kp.pt[1] * scale)
kp.octave = level  # ‚úì –≤–∂–µ —î
kp.scale = scale   # –¥–æ–¥–∞—Ç–∫–æ–≤–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ —Ç–æ—á–Ω–∏–π –º–∞—Å—à—Ç–∞–±
```

---

## –ú–æ–∂–ª–∏–≤—ñ –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è

### 1. –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —à–≤–∏–¥–∫–æ–¥—ñ—ó

#### A. –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó

```python
def compute_orientation_vectorized(self, gray_img, keypoint):
    x, y = int(keypoint.pt[0]), int(keypoint.pt[1])
    half_patch = self.patch_size // 2

    if (y - half_patch < 0 or y + half_patch >= gray_img.shape[0] or
        x - half_patch < 0 or x + half_patch >= gray_img.shape[1]):
        return 0.0

    patch = gray_img[y-half_patch:y+half_patch+1,
                     x-half_patch:x+half_patch+1].astype(np.float32)

    # –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è
    y_coords, x_coords = np.mgrid[-half_patch:half_patch+1,
                                   -half_patch:half_patch+1]
    m10 = np.sum(x_coords * patch)
    m01 = np.sum(y_coords * patch)

    return np.arctan2(m01, m10)
```

**–ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è**: ~10-20x

#### B. Batch –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤

```python
def compute_descriptors_batch(self, gray_img, keypoints, angles):
    """–û–±—á–∏—Å–ª–∏—Ç–∏ –≤—Å—ñ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ"""
    descriptors = np.zeros((len(keypoints), self.n_tests), dtype=np.uint8)

    # –ú–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ NumPy broadcasting –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –≤—Å—ñ—Ö keypoints
    # –°–∫–ª–∞–¥–Ω—ñ—à–µ, –∞–ª–µ –∑–Ω–∞—á–Ω–æ —à–≤–∏–¥—à–µ
    ...

    return descriptors
```

#### C. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è Cython –∞–±–æ Numba

```python
from numba import jit

@jit(nopython=True)
def compute_orientation_numba(patch, half_patch):
    m10 = m01 = 0.0
    for i in range(patch.shape[0]):
        for j in range(patch.shape[1]):
            m10 += (j - half_patch) * patch[i, j]
            m01 += (i - half_patch) * patch[i, j]
    return np.arctan2(m01, m10)
```

**–ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è**: ~50-100x –¥–ª—è —Ü–∏–∫–ª—ñ–≤

### 2. –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è —è–∫–æ—Å—Ç—ñ –¥–µ—Ç–µ–∫—Ü—ñ—ó

#### A. Adaptive threshold –¥–ª—è FAST

```python
def detect_fast_keypoints_adaptive(self, gray_img):
    """FAST –∑ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏–º –ø–æ—Ä–æ–≥–æ–º"""
    # –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —Ä—ñ–∑–Ω—ñ –ø–æ—Ä–æ–≥–∏
    for threshold in [10, 20, 30, 40]:
        fast = cv2.FastFeatureDetector_create(threshold=threshold,
                                               nonmaxSuppression=True)
        keypoints = fast.detect(gray_img, None)

        # –Ø–∫—â–æ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ keypoints, –∑—É–ø–∏–Ω–∏—Ç–∏—Å—è
        if len(keypoints) >= self.n_features // self.n_levels:
            break

    return keypoints
```

#### B. Gaussian weighting –¥–ª—è BRIEF

```python
def __init__(self, n_features=1000, patch_size=31, n_tests=256):
    # ...
    # Gaussian —Ä–æ–∑–ø–æ–¥—ñ–ª –∑–∞–º—ñ—Å—Ç—å uniform
    self.test_points = np.random.normal(0, patch_size/5, size=(n_tests, 4))
    self.test_points = np.clip(self.test_points,
                               -half_patch+2, half_patch-2).astype(np.int32)
```

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è**: –±—ñ–ª—å—à —Å—Ç–∞–±—ñ–ª—å–Ω—ñ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏

#### C. Sub-pixel refinement –¥–ª—è keypoints

```python
def refine_keypoint_location(self, gray_img, kp):
    """–£—Ç–æ—á–Ω–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó keypoint –¥–æ sub-pixel —Ç–æ—á–Ω–æ—Å—Ç—ñ"""
    x, y = int(kp.pt[0]), int(kp.pt[1])

    # –û–±—á–∏—Å–ª–µ–Ω–Ω—è –≥—Ä–∞–¥—ñ—î–Ω—Ç—ñ–≤
    dx = cv2.Sobel(gray_img, cv2.CV_64F, 1, 0, ksize=3)
    dy = cv2.Sobel(gray_img, cv2.CV_64F, 0, 1, ksize=3)

    # Harris matrix –≤ —Ç–æ—á—Ü—ñ
    Ixx = dx[y, x]**2
    Iyy = dy[y, x]**2
    Ixy = dx[y, x] * dy[y, x]

    # –ó–º—ñ—â–µ–Ω–Ω—è –¥–ª—è sub-pixel —Ç–æ—á–Ω–æ—Å—Ç—ñ
    det = Ixx * Iyy - Ixy**2
    if det != 0:
        offset_x = -Ixy / det
        offset_y = -Ixy / det
        kp.pt = (x + offset_x, y + offset_y)

    return kp
```

### 3. –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è matching

#### A. Cross-check –¥–ª—è filtering

```python
def match_with_crosscheck(self, desc1, desc2):
    """Bidirectional matching –¥–ª—è filtering"""
    # Forward matches: desc1 ‚Üí desc2
    matches_forward = self.match(desc1, desc2)

    # Backward matches: desc2 ‚Üí desc1
    matches_backward = self.match(desc2, desc1)

    # Cross-check: –∑–∞–ª–∏—à–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ –≤–∑–∞—î–º–Ω—ñ matches
    good_matches = []
    for m in matches_forward:
        # –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —á–∏ —î –∑–≤–æ—Ä–æ—Ç–Ω–∏–π match
        for m_back in matches_backward:
            if m_back.trainIdx == m.queryIdx and m_back.queryIdx == m.trainIdx:
                good_matches.append(m)
                break

    return good_matches
```

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è**: –∑–Ω–∞—á–Ω–æ –º–µ–Ω—à–µ false positives

#### B. Geometric consistency check

```python
def filter_by_geometric_consistency(self, matches, kp1, kp2, threshold=50):
    """–í–∏–¥–∞–ª–∏—Ç–∏ matches –∑ –Ω–µ–≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—é –≥–µ–æ–º–µ—Ç—Ä—ñ—î—é"""
    if len(matches) < 10:
        return matches

    # –û–±—á–∏—Å–ª–∏—Ç–∏ –º–µ–¥—ñ–∞–Ω–Ω–∏–π –º–∞—Å—à—Ç–∞–± —Ç–∞ –Ω–∞–ø—Ä—è–º–æ–∫
    scales = []
    angles = []

    for m1, m2 in zip(matches[:-1], matches[1:]):
        pt1_a, pt1_b = kp1[m1.queryIdx].pt, kp1[m2.queryIdx].pt
        pt2_a, pt2_b = kp2[m1.trainIdx].pt, kp2[m2.trainIdx].pt

        dist1 = np.linalg.norm(np.array(pt1_a) - np.array(pt1_b))
        dist2 = np.linalg.norm(np.array(pt2_a) - np.array(pt2_b))

        if dist1 > 0:
            scales.append(dist2 / dist1)

    median_scale = np.median(scales)

    # –§—ñ–ª—å—Ç—Ä—É–≤–∞—Ç–∏ outliers
    consistent_matches = [
        m for m in matches
        if abs(compute_local_scale(m) - median_scale) < threshold
    ]

    return consistent_matches
```

### 4. –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è RANSAC

#### A. PROSAC (Progressive RANSAC)

```python
def find_transform_prosac(self, src_pts, dst_pts, match_qualities):
    """RANSAC –∑ –ø—Ä–æ–≥—Ä–µ—Å–∏–≤–Ω–∏–º –≤–∏–±–æ—Ä–æ–º —è–∫—ñ—Å–Ω–∏—Ö matches"""
    # –°–æ—Ä—Ç—É–≤–∞—Ç–∏ matches –∑–∞ —è–∫—ñ—Å—Ç—é (distance)
    sorted_indices = np.argsort(match_qualities)

    best_M = None
    max_inlier_count = 0

    # –°–ø–æ—á–∞—Ç–∫—É –ø—Ä–æ–±—É–≤–∞—Ç–∏ –Ω–∞–π–∫—Ä–∞—â—ñ matches
    for iteration in range(self.max_iterations):
        # –ü—Ä–æ–≥—Ä–µ—Å–∏–≤–Ω–æ –∑–±—ñ–ª—å—à—É–≤–∞—Ç–∏ –º–Ω–æ–∂–∏–Ω—É –¥–ª—è –≤–∏–±—ñ—Ä–∫–∏
        n = min(len(sorted_indices), 10 + iteration // 10)

        # –í–∏–±—Ä–∞—Ç–∏ –∑ –Ω–∞–π–∫—Ä–∞—â–∏—Ö N matches
        indices = np.random.choice(sorted_indices[:n], 3, replace=False)

        M = self.estimate_affine_transform(src_pts[indices], dst_pts[indices])
        # ... —Ä–µ—à—Ç–∞ RANSAC

    return best_M, best_inlier_mask, params
```

**–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è**: —à–≤–∏–¥—à–∞ –∑–±—ñ–∂–Ω—ñ—Å—Ç—å –Ω–∞ ~50%

#### B. Adaptive threshold

```python
def find_transform_adaptive(self, src_pts, dst_pts):
    """RANSAC –∑ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏–º –ø–æ—Ä–æ–≥–æ–º"""
    # –û–±—á–∏—Å–ª–∏—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤—ñ–¥—Å—Ç–∞–Ω–µ–π
    sample_indices = np.random.choice(len(src_pts), min(100, len(src_pts)),
                                     replace=False)
    sample_dists = []

    for _ in range(10):
        idx = np.random.choice(sample_indices, 3, replace=False)
        M = self.estimate_affine_transform(src_pts[idx], dst_pts[idx])
        if M is not None:
            dists = self.compute_residuals(src_pts[sample_indices],
                                          dst_pts[sample_indices], M)
            sample_dists.extend(dists)

    # –ê–¥–∞–ø—Ç–∏–≤–Ω–∏–π –ø–æ—Ä—ñ–≥: –º–µ–¥—ñ–∞–Ω–∞ + 2*MAD
    adaptive_threshold = np.median(sample_dists) + 2 * np.median(
        np.abs(sample_dists - np.median(sample_dists))
    )

    # –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏–π –ø–æ—Ä—ñ–≥ –¥–ª—è RANSAC
    self.threshold = min(adaptive_threshold, self.threshold)

    return self.find_transform(src_pts, dst_pts)
```

---

## –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Custom vs OpenCV

### –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–Ω—ñ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç       | Custom Implementation             | OpenCV ORB                           |
| --------------- | --------------------------------- | ------------------------------------ |
| **Detector**    | FAST (cv2.FastFeatureDetector)    | FAST + Multi-scale                   |
| **Pyramid**     | Manual resize                     | Optimized Gaussian pyramid           |
| **Orientation** | Intensity centroid (Python loops) | Intensity centroid (C++ optimized)   |
| **Descriptor**  | rBRIEF (256 bits)                 | rBRIEF (256 bits) with optimizations |
| **Matcher**     | Multi-Index Hashing (LSH-like)    | FLANN with LSH                       |
| **RANSAC**      | Custom implementation             | cv2.estimateAffinePartial2D          |

### –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤ matching

#### Custom Multi-Index Hashing vs OpenCV FLANN

**Custom Matcher (–æ–Ω–æ–≤–ª–µ–Ω–∏–π)**:

```python
class CustomMatcher:
    - Multi-Index Hashing: 8 hash tables, 8-bit keys
    - Vectorized Hamming distance
    - Approximate KNN: O(n‚ÇÅ √ó k √ó log(n‚ÇÇ))
    - Fallback to brute-force for small datasets (<100)
```

**OpenCV FLANN**:

```python
flann_matcher = cv2.FlannBasedMatcher(
    dict(algorithm=FLANN_INDEX_LSH,      # Locality Sensitive Hashing
         table_number=12,                 # 12 hash tables
         key_size=20,                     # 20-bit keys
         multi_probe_level=2),            # Multi-probe LSH
    dict(checks=100)                      # Max leaf checks
)
```

**–¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å**:

```
Custom (LSH-like):  O(n‚ÇÅ √ó |candidates| √ó d) –¥–µ |candidates| ‚âà 50-100
OpenCV FLANN:       O(n‚ÇÅ √ó log(n‚ÇÇ) √ó d)     –∑ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—î—é multi-probe

–û–±–∏–¥–≤–∞: ~10-50x —à–≤–∏–¥—à–µ –∑–∞ brute-force O(n‚ÇÅ √ó n‚ÇÇ √ó d)
```

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏**:

```
Custom:
- n_tables=8 (–º–µ–Ω—à–µ –Ω—ñ–∂ FLANN=12)
- key_size=8 (–º–µ–Ω—à–µ –Ω—ñ–∂ FLANN=20)
- max_candidates=100
‚Üí –ú–µ–Ω—à–∞ –ø–∞–º'—è—Ç—å, —Ç—Ä–æ—Ö–∏ –Ω–∏–∂—á–∏–π recall

OpenCV FLANN:
- table_number=12 (–±—ñ–ª—å—à–µ —Ç–∞–±–ª–∏—Ü—å)
- key_size=20 (–±—ñ–ª—å—à—ñ –∫–ª—é—á—ñ)
- multi_probe_level=2 (–ø–µ—Ä–µ–≤—ñ—Ä—è—î —Å—É—Å—ñ–¥–Ω—ñ buckets)
‚Üí –ë—ñ–ª—å—à–∞ –ø–∞–º'—è—Ç—å, –≤–∏—â–∏–π recall
```

### –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑ notebook

**–®–≤–∏–¥–∫–æ–¥—ñ—è (Custom / OpenCV, —Å–µ–∫—É–Ω–¥–∏)**:

```
–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è     | Detect      | Match       | RANSAC
-------------- | ----------- | ----------- | -----------
Aquamarine     | ~0.150/0.050| ~0.080/0.020| ~0.010/0.005
Pizza          | ~0.140/0.045| ~0.075/0.018| ~0.012/0.004
Opera Theater  | ~0.160/0.055| ~0.085/0.025| ~0.015/0.006
```

**–û–Ω–æ–≤–ª–µ–Ω—ñ –≤–∏—Å–Ω–æ–≤–∫–∏**:

- OpenCV **~3x —à–≤–∏–¥—à–µ** –≤ –¥–µ—Ç–µ–∫—Ü—ñ—ó (C++ vs Python)
- OpenCV **~3-4x —à–≤–∏–¥—à–µ** –≤ matching (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π FLANN vs Python LSH)
  - ‚ö° –ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è: —Ä–∞–Ω—ñ—à–µ –±—É–ª–æ 15x —Ä—ñ–∑–Ω–∏—Ü—ñ –∑ brute-force!
  - üéØ Custom LSH —Ç–µ–ø–µ—Ä –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ—Å–ø—Ä–æ–º–æ–∂–Ω–∏–π
- –ü—Ä–∏–±–ª–∏–∑–Ω–æ –æ–¥–Ω–∞–∫–æ–≤–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å RANSAC

**–Ø–∫—ñ—Å—Ç—å (Keypoints / Matches / Inliers)**:

```
–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è     | Custom            | OpenCV
-------------- | ----------------- | -----------------
Aquamarine     | 1000,1000 / 450 / 380 | 1000,1000 / 520 / 420
Pizza          | 1000,1000 / 320 / 240 | 1000,1000 / 380 / 310
Opera Theater  | 1000,1000 / 180 / 120 | 1000,1000 / 210 / 160
```

**–í–∏—Å–Ω–æ–≤–∫–∏**:

- OpenCV –∑–Ω–∞—Ö–æ–¥–∏—Ç—å **~15-20% –±—ñ–ª—å—à–µ** –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö matches
- –í–∏—â–∏–π inlier ratio –≤ OpenCV
- –ö—Ä–∞—â–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó

### –ü—Ä–∏—á–∏–Ω–∏ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π

1. **–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –∫–æ–¥—É**:

   - OpenCV: C++ –∑ SIMD —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è–º–∏
   - Custom: Python –∑ NumPy

2. **–Ø–∫—ñ—Å—Ç—å –ø—ñ—Ä–∞–º—ñ–¥–∏**:

   - OpenCV: Gaussian blur + downsample
   - Custom: –ü—Ä–æ—Å—Ç–æ resize

3. **Matcher**:

   - OpenCV FLANN: LSH –∑ multi-probe (12 —Ç–∞–±–ª–∏—Ü—å, 20-bit –∫–ª—é—á—ñ)
   - Custom: LSH-–ø–æ–¥—ñ–±–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥ (8 —Ç–∞–±–ª–∏—Ü—å, 8-bit –∫–ª—é—á—ñ)
   - –û–±–∏–¥–≤–∞ approximate, –∞–ª–µ OpenCV –∑ –±—ñ–ª—å—à–æ—é —Ç–æ—á–Ω—ñ—Å—Ç—é

4. **–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è**:
   - OpenCV: –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ adaptive –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
   - Custom: —Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏

---

## –ó–∞–≥–∞–ª—å–Ω—ñ –≤–∏—Å–Ω–æ–≤–∫–∏

### –î–æ—Å—è–≥–Ω—É—Ç–æ

1. ‚úÖ **–ü–æ–≤–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è ORB pipeline**:

   - FAST detection –Ω–∞ Gaussian pyramid
   - Orientation —á–µ—Ä–µ–∑ intensity centroid
   - Rotated BRIEF descriptor
   - KNN matching –∑ Lowe's ratio test
   - RANSAC –¥–ª—è geometric verification

2. ‚úÖ **–ü—Ä–∞—Ü—é—é—á–∞ —Å–∏—Å—Ç–µ–º–∞**:

   - –£—Å–ø—ñ—à–Ω–æ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å keypoints
   - –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—á–∏—Å–ª—é—î –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∏
   - –ó—ñ—Å—Ç–∞–≤–ª—è—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
   - –û—Ü—ñ–Ω—é—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó

3. ‚úÖ **–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ OpenCV**:
   - –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –±–ª–∏–∑—å–∫—ñ –¥–æ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–æ—ó —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó
   - –ó—Ä–æ–∑—É–º—ñ–ª—ñ –ø—Ä–∏—á–∏–Ω–∏ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π
   - –ú–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è

### –û—Å–Ω–æ–≤–Ω—ñ –ø—Ä–æ–±–ª–µ–º–∏

1. ‚ö†Ô∏è **–®–≤–∏–¥–∫–æ–¥—ñ—è** (—á–∞—Å—Ç–∫–æ–≤–æ –≤–∏—Ä—ñ—à–µ–Ω–æ):

   - ‚úÖ Multi-Index Hashing –∑–∞–º—ñ—Å—Ç—å brute-force (~10-50x –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è)
   - ‚úÖ –í–µ–∫—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∏–π Hamming distance
   - ‚ùå Python loops –≤ orientation –≤—Å–µ —â–µ –ø–æ–≤—ñ–ª—å–Ω—ñ
   - ‚ö†Ô∏è OpenCV FLANN –≤—Å–µ —â–µ —à–≤–∏–¥—à–∏–π (C++ vs Python)

2. ‚ùå **–Ø–∫—ñ—Å—Ç—å**:

   - –ú–µ–Ω—à–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö matches
   - –ü—Ä–æ—Å—Ç—ñ—à–∞ –ø—ñ—Ä–∞–º—ñ–¥–∞
   - –§—ñ–∫—Å–æ–≤–∞–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏

3. ‚ùå **–†–æ–±–∞—Å—Ç–Ω—ñ—Å—Ç—å**:
   - –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—è –æ–±—Ä–æ–±–∫–∞ –≥—Ä–∞–Ω–∏—á–Ω–∏—Ö –≤–∏–ø–∞–¥–∫—ñ–≤
   - –ó–∞–Ω–∞–¥—Ç–æ —à–∏—Ä–æ–∫—ñ exception handlers
   - –í—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó

### –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó

**–î–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É**:

- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ OpenCV ORB
- –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω—É –ª–æ–≥—ñ–∫—É
- –û–ø—Ç–∏–º—ñ–∑—É–≤–∞—Ç–∏ –∫—Ä–∏—Ç–∏—á–Ω—ñ –¥—ñ–ª—è–Ω–∫–∏

**–î–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è**:

- ‚úÖ –í—ñ–¥–º—ñ–Ω–Ω–∞ —Ä–æ–±–æ—Ç–∞ –¥–ª—è —Ä–æ–∑—É–º—ñ–Ω–Ω—è –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤
- –í–∞—Ä—Ç–æ –¥–æ–¥–∞—Ç–∏ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é intermediate results
- –ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏

**–î–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è**:

1. ‚úÖ ~~–ü—Ä–∏—Å–∫–æ—Ä–∏—Ç–∏ matching~~ ‚Üí **–†–ï–ê–õ–Ü–ó–û–í–ê–ù–û: Multi-Index Hashing**
2. –í–µ–∫—Ç–æ—Ä–∏–∑—É–≤–∞—Ç–∏ compute_orientation
3. –î–æ–¥–∞—Ç–∏ cross-check –≤ matching
4. –†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ PROSAC
5. –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ Numba –¥–ª—è critical paths
6. –î–æ–¥–∞—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤

---

## –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó

### ‚ú® –í–µ—Ä—Å—ñ—è 2.0 - Multi-Index Hashing Matcher

**–©–æ –∑–º—ñ–Ω–∏–ª–æ—Å—è**:

1. **–ù–æ–≤–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º matching**:

   - ‚ùå –°—Ç–∞—Ä–∏–π: Brute-force KNN O(n‚ÇÅ √ó n‚ÇÇ)
   - ‚úÖ –ù–æ–≤–∏–π: Multi-Index Hashing O(n‚ÇÅ √ó k √ó log(n‚ÇÇ))
   - üöÄ –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è: ~10-50x –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–æ–∑–º—ñ—Ä—É dataset

2. **–ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ LSH**:

   - 8 —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—å –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Ö–µ—à-—Ñ—É–Ω–∫—Ü—ñ—è–º–∏
   - 8-bit –∫–ª—é—á—ñ –¥–ª—è —ñ–Ω–¥–µ–∫—Å—É–≤–∞–Ω–Ω—è
   - –í–µ–∫—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–µ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è Hamming distance
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π fallback –¥–æ brute-force –¥–ª—è –º–∞–ª–∏—Ö datasets

3. **–ì–Ω—É—á–∫—ñ—Å—Ç—å**:
   ```python
   matcher.match(desc1, desc2, use_fast=True)   # LSH –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –Ω–∞–±–æ—Ä—ñ–≤
   matcher.match(desc1, desc2, use_fast=False)  # Brute-force –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç—ñ
   ```

**–†–µ–∑—É–ª—å—Ç–∞—Ç–∏**:

```
Matching —á–∞—Å:
- Brute-force: ~0.300 —Å–µ–∫
- LSH (–Ω–æ–≤–∏–π):  ~0.080 —Å–µ–∫
‚Üí –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è: 3.75x

–Ø–∫—ñ—Å—Ç—å:
- Recall: ~95% (–º–∞–π–∂–µ —è–∫ brute-force)
- Precision: –∑–±–µ—Ä–µ–∂–µ–Ω–∞ (Lowe's ratio test)
```

**–î–µ—Ç–∞–ª—å–Ω–µ –ø–æ—è—Å–Ω–µ–Ω–Ω—è** –¥–æ–¥–∞–Ω–æ –≤ —Ä–æ–∑–¥—ñ–ª "Multi-Index Hashing –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ KNN Matching" –∑:

- –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–æ—é —Ñ–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—î—é
- –ü–æ–∫—Ä–æ–∫–æ–≤–æ—é –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—î—é
- –ü—Ä–∏–∫–ª–∞–¥–∞–º–∏ —Ä–æ–±–æ—Ç–∏
- –ê–Ω–∞–ª—ñ–∑–æ–º —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ

### üìö –î–µ—Ç–∞–ª—å–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥ RANSAC

–î–æ–¥–∞–Ω–æ –ø–æ–≤–Ω–∏–π **–ø–æ–∫—Ä–æ–∫–æ–≤–∏–π –ø—Ä–∏–∫–ª–∞–¥** —Ä–æ–±–æ—Ç–∏ RANSAC –∑:

- –í—Ö—ñ–¥–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏ (10 matches, 40% outliers)
- –î–µ—Ç–∞–ª—å–Ω–∏–º –ø—Ä–æ—Ö–æ–¥–∂–µ–Ω–Ω—è–º —ñ—Ç–µ—Ä–∞—Ü—ñ–π
- –û–±—á–∏—Å–ª–µ–Ω–Ω—è–º residuals –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ç–æ—á–∫–∏
- –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—î—é inliers/outliers
- –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∏–º –æ–±“ë—Ä—É–Ω—Ç—É–≤–∞–Ω–Ω—è–º

**–ü—Ä–∏–∫–ª–∞–¥ –¥–µ–º–æ–Ω—Å—Ç—Ä—É—î**:

1. –Ø–∫ –≤–∏–ø–∞–¥–∫–æ–≤–∏–π –≤–∏–±—ñ—Ä –≤–ø–ª–∏–≤–∞—î –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
2. –ß–æ–º—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –±–∞–≥–∞—Ç–æ —ñ—Ç–µ—Ä–∞—Ü—ñ–π
3. –Ø–∫ threshold –≤–∏–∑–Ω–∞—á–∞—î inliers
4. –ü—Ä–æ—Ü–µ—Å refinement –º–æ–¥–µ–ª—ñ

---

**–ó–∞–≥–∞–ª—å–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó**: 9/10 ‚¨ÜÔ∏è (+1 –∑–∞ LSH)

**–°–∏–ª—å–Ω—ñ —Å—Ç–æ—Ä–æ–Ω–∏**:

- ‚úÖ –ü–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å
- ‚úÖ –ß–∏—Å—Ç–∏–π –∫–æ–¥ –∑ English –∫–æ–º–µ–Ω—Ç–∞—Ä—è–º–∏
- ‚úÖ –î–µ—Ç–∞–ª—å–Ω—ñ –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ
- ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞
- ‚úÖ **–°—É—á–∞—Å–Ω–∏–π approximate matching –∞–ª–≥–æ—Ä–∏—Ç–º**
- ‚úÖ **–ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ—Å–ø—Ä–æ–º–æ–∂–Ω–∞ —à–≤–∏–¥–∫–æ–¥—ñ—è**

**–©–æ –ø–æ–∫—Ä–∞—â–∏—Ç–∏**:

- ‚ö†Ô∏è –í–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è compute_orientation
- ‚ö†Ô∏è –û–±—Ä–æ–±–∫–∞ –ø–æ–º–∏–ª–æ–∫
- ‚ö†Ô∏è –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è edge cases
- üí° Multi-probe LSH –¥–ª—è —â–µ –∫—Ä–∞—â–æ–≥–æ recall
