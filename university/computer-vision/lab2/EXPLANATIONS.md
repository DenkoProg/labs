# –ü–æ—è—Å–Ω–µ–Ω–Ω—è —Ç–µ—Ä–º—ñ–Ω—ñ–≤ —Ç–∞ –∫–æ–¥—É - –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ —Ä–æ–±–æ—Ç–∞ 2

## –ó–º—ñ—Å—Ç

1. [–û—Å–Ω–æ–≤–Ω—ñ —Ç–µ—Ä–º—ñ–Ω–∏](#–æ—Å–Ω–æ–≤–Ω—ñ-—Ç–µ—Ä–º—ñ–Ω–∏)
2. [–ê–ª–≥–æ—Ä–∏—Ç–º–∏ —Ç–∞ –º–µ—Ç–æ–¥–∏](#–∞–ª–≥–æ—Ä–∏—Ç–º–∏-—Ç–∞-–º–µ—Ç–æ–¥–∏)
3. [–î–µ—Ç–∞–ª—å–Ω–∏–π —Ä–æ–∑–±—ñ—Ä –∫–æ–¥—É](#–¥–µ—Ç–∞–ª—å–Ω–∏–π-—Ä–æ–∑–±—ñ—Ä-–∫–æ–¥—É)
4. [–ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏](#–º–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ-–æ—Å–Ω–æ–≤–∏)

---

## –û—Å–Ω–æ–≤–Ω—ñ —Ç–µ—Ä–º—ñ–Ω–∏

### Feature Detection (–í–∏—è–≤–ª–µ–Ω–Ω—è –æ–∑–Ω–∞–∫)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ü—Ä–æ—Ü–µ—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–∏—Ö —Ç–æ—á–æ–∫ (features) –Ω–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ, —è–∫—ñ –º–æ–∂–Ω–∞ –Ω–∞–¥—ñ–π–Ω–æ –≤–∏—è–≤–∏—Ç–∏ –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è—Ö.

**–ü—Ä–∏–∫–ª–∞–¥–∏**: –∫—É—Ç–∏, –∫—Ä–∞—ó, blob-—Å—Ç—Ä—É–∫—Ç—É—Ä–∏

**–ß–æ–º—É –≤–∞–∂–ª–∏–≤–æ**: –û–∑–Ω–∞–∫–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –¥–ª—è –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å, —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –æ–±'—î–∫—Ç—ñ–≤, 3D-—Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó.

---

### Keypoint (–ö–ª—é—á–æ–≤–∞ —Ç–æ—á–∫–∞)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –•–∞—Ä–∞–∫—Ç–µ—Ä–Ω–∞ —Ç–æ—á–∫–∞ –Ω–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ –∑ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–º–∏ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏, —è–∫—É –º–æ–∂–Ω–∞ –Ω–∞–¥—ñ–π–Ω–æ –∑–Ω–∞–π—Ç–∏ –Ω–∞ —ñ–Ω—à–∏—Ö –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è—Ö —Ç–æ–≥–æ –∂ –æ–±'—î–∫—Ç–∞.

**–í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ**:

- `pt` (x, y) - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ç–æ—á–∫–∏
- `size` - —Ä–æ–∑–º—ñ—Ä –æ–∫–æ–ª–∏—Ü—ñ
- `angle` - –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è
- `response` - —Å–∏–ª–∞ –≤—ñ–¥–≥—É–∫—É –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞

**–£ –∫–æ–¥—ñ**:

```python
cv2.KeyPoint(float(x), float(y), self.patch_size, response=float(harris[y, x]))
```

---

### Descriptor (–î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ö–æ–º–ø–∞–∫—Ç–Ω–µ —á–∏—Å–ª–æ–≤–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –æ–∫–æ–ª–∏—Ü—ñ –∫–ª—é—á–æ–≤–æ—ó —Ç–æ—á–∫–∏, —è–∫–µ –¥–æ–∑–≤–æ–ª—è—î –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ —Ä—ñ–∑–Ω—ñ —Ç–æ—á–∫–∏ –º—ñ–∂ —Å–æ–±–æ—é.

**–¢–∏–ø–∏**:

- **–ë—ñ–Ω–∞—Ä–Ω—ñ** (BRIEF, ORB) - –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –±—ñ—Ç—ñ–≤
- **Floating-point** (SIFT, SURF) - –≤–µ–∫—Ç–æ—Ä–∏ –¥—ñ–π—Å–Ω–∏—Ö —á–∏—Å–µ–ª

**–£ –∫–æ–¥—ñ**:

```python
descriptor = np.zeros(self.n_tests, dtype=np.uint8)  # 256 –±—ñ—Ç
```

---

### ORB (Oriented FAST and Rotated BRIEF)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –®–≤–∏–¥–∫–∏–π —Ç–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä, —â–æ –ø–æ—î–¥–Ω—É—î –¥–µ—Ç–µ–∫—Ç–æ—Ä –∫—É—Ç—ñ–≤ –∑ –±—ñ–Ω–∞—Ä–Ω–∏–º –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–æ–º.

**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏**:

1. **FAST** (Features from Accelerated Segment Test) –∞–±–æ **Harris Corner Detector**
2. **Orientation** - –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó —á–µ—Ä–µ–∑ intensity centroid
3. **BRIEF** (Binary Robust Independent Elementary Features)

**–ü–µ—Ä–µ–≤–∞–≥–∏**:

- –®–≤–∏–¥–∫–∏–π (‚àº100√ó —à–≤–∏–¥—à–µ –∑–∞ SIFT)
- Rotation invariant (–æ–±–µ—Ä—Ç–æ–≤–æ-—ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–Ω–∏–π)
- –ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏–π (–Ω–µ –∑–∞—Ö–∏—â–µ–Ω–∏–π –ø–∞—Ç–µ–Ω—Ç–∞–º–∏)

---

### Harris Corner Detector

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ê–ª–≥–æ—Ä–∏—Ç–º –≤–∏—è–≤–ª–µ–Ω–Ω—è –∫—É—Ç—ñ–≤, —â–æ –∞–Ω–∞–ª—ñ–∑—É—î –∑–º—ñ–Ω–∏ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ –≤ —Ä—ñ–∑–Ω–∏—Ö –Ω–∞–ø—Ä—è–º–∫–∞—Ö.

**–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞**:

```
M = [I‚Çì¬≤   I‚ÇìI·µß]
    [I‚ÇìI·µß  I·µß¬≤  ]

R = det(M) - k¬∑trace¬≤(M)
  = Œª‚ÇÅŒª‚ÇÇ - k(Œª‚ÇÅ + Œª‚ÇÇ)¬≤
```

–î–µ:

- `I‚Çì`, `I·µß` - –≥—Ä–∞–¥—ñ—î–Ω—Ç–∏ –ø–æ x —Ç–∞ y
- `Œª‚ÇÅ`, `Œª‚ÇÇ` - –≤–ª–∞—Å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –º–∞—Ç—Ä–∏—Ü—ñ M
- `k ‚âà 0.04` - –µ–º–ø—ñ—Ä–∏—á–Ω–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç

**–£ –∫–æ–¥—ñ**:

```python
def compute_harris_response(self, gray_img):
    Ix = cv2.Sobel(gray_img, cv2.CV_64F, 1, 0, ksize=3)
    Iy = cv2.Sobel(gray_img, cv2.CV_64F, 0, 1, ksize=3)

    Sxx = cv2.GaussianBlur(Ix * Ix, (5, 5), 0)
    Syy = cv2.GaussianBlur(Iy * Iy, (5, 5), 0)
    Sxy = cv2.GaussianBlur(Ix * Iy, (5, 5), 0)

    det = Sxx * Syy - Sxy * Sxy
    trace = Sxx + Syy

    return det - 0.04 * (trace**2)
```

**–Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è**:

- –í–∏—Å–æ–∫–∏–π `R` ‚Üí –∫—É—Ç
- `R < 0` ‚Üí –∫—Ä–∞–π
- –ú–∞–ª–∏–π `R` ‚Üí –ø–ª–æ—Å–∫–∞ –æ–±–ª–∞—Å—Ç—å

---

### Non-Maximum Suppression (NMS)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ú–µ—Ç–æ–¥ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó, —â–æ –∑–∞–ª–∏—à–∞—î —Ç—ñ–ª—å–∫–∏ –ª–æ–∫–∞–ª—å–Ω—ñ –º–∞–∫—Å–∏–º—É–º–∏ –≤ –º–µ–∂–∞—Ö –æ–∫–æ–ª–∏—Ü—ñ.

**–ú–µ—Ç–∞**: –£–Ω–∏–∫–Ω–µ–Ω–Ω—è —Å–∫—É–ø—á–µ–Ω–Ω—è –∫–ª—é—á–æ–≤–∏—Ö —Ç–æ—á–æ–∫, –≤–∏–±—ñ—Ä –Ω–∞–π—Å–∏–ª—å–Ω—ñ—à–∏—Ö.

**–£ –∫–æ–¥—ñ**:

```python
kernel_size = 9
harris_dilated = cv2.dilate(harris, np.ones((kernel_size, kernel_size)))
keypoint_mask = (harris > threshold) & (harris == harris_dilated)
```

**–Ø–∫ –ø—Ä–∞—Ü—é—î**:

1. –î–∏–ª–∞—Ç–∞—Ü—ñ—è —Ä–æ–∑—à–∏—Ä—é—î –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞ 9√ó9 –æ–±–ª–∞—Å—Ç—å
2. –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª –∑ –¥–∏–ª–∞—Ç–æ–≤–∞–Ω–∏–º
3. –¢–æ—á–∫–∞ –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤–æ–Ω–∞ —î –ª–æ–∫–∞–ª—å–Ω–∏–º –º–∞–∫—Å–∏–º—É–º–æ–º

---

### BRIEF (Binary Robust Independent Elementary Features)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ë—ñ–Ω–∞—Ä–Ω–∏–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –ø–∞—Ä –ø—ñ–∫—Å–µ–ª—ñ–≤.

**–ê–ª–≥–æ—Ä–∏—Ç–º**:

1. –í–∏–±–∏—Ä–∞—î–º–æ N –ø–∞—Ä —Ç–æ—á–æ–∫ (x‚ÇÅ,y‚ÇÅ), (x‚ÇÇ,y‚ÇÇ) –≤ –ø–∞—Ç—á—ñ
2. –î–ª—è –∫–æ–∂–Ω–æ—ó –ø–∞—Ä–∏ –ø–æ—Ä—ñ–≤–Ω—é—î–º–æ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ:
   ```
   œÑ(p; x‚ÇÅ,y‚ÇÅ, x‚ÇÇ,y‚ÇÇ) = 1 if I(x‚ÇÅ,y‚ÇÅ) < I(x‚ÇÇ,y‚ÇÇ) else 0
   ```
3. –î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä = –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü—ñ—è –≤—Å—ñ—Ö –±—ñ—Ç—ñ–≤

**–£ –∫–æ–¥—ñ**:

```python
for i, (x1, y1, x2, y2) in enumerate(rotated):
    px1, py1, px2, py2 = y + y1, x + x1, y + y2, x + x2

    if (0 <= px1 < gray_img.shape[0] and 0 <= py1 < gray_img.shape[1] and
        0 <= px2 < gray_img.shape[0] and 0 <= py2 < gray_img.shape[1]):
        descriptor[i] = 1 if gray_img[px1, py1] < gray_img[px2, py2] else 0
```

**–ü–µ—Ä–µ–≤–∞–≥–∏**:

- –î—É–∂–µ —à–≤–∏–¥–∫–∏–π (–ø—Ä–æ—Å—Ç–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è)
- –ö–æ–º–ø–∞–∫—Ç–Ω–∏–π (256 –±—ñ—Ç)
- –õ–µ–≥–∫–æ –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ (Hamming distance)

---

### Orientation (–û—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ì–æ–ª–æ–≤–Ω–∏–π –Ω–∞–ø—Ä—è–º–æ–∫ –ø–∞—Ç—á—É, –æ–±—á–∏—Å–ª–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Ä–æ–∑–ø–æ–¥—ñ–ª —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ.

**–ú–µ—Ç–æ–¥ Intensity Centroid**:

```
m‚ÇÅ‚ÇÄ = Œ£ x¬∑I(x,y)
m‚ÇÄ‚ÇÅ = Œ£ y¬∑I(x,y)

Œ∏ = atan2(m‚ÇÄ‚ÇÅ, m‚ÇÅ‚ÇÄ)
```

**–£ –∫–æ–¥—ñ**:

```python
def compute_orientation(self, gray_img, keypoint):
    patch = gray_img[y-half_patch:y+half_patch+1,
                     x-half_patch:x+half_patch+1]

    m10 = m01 = 0.0
    for i in range(patch.shape[0]):
        for j in range(patch.shape[1]):
            m10 += (j - half_patch) * patch[i, j]
            m01 += (i - half_patch) * patch[i, j]

    return np.arctan2(m01, m10)
```

**–ù–∞–≤—ñ—â–æ**: –î–æ–∑–≤–æ–ª—è—î –æ–±–µ—Ä—Ç–∞—Ç–∏ BRIEF –ø–∞—Ç—á —É –∫–∞–Ω–æ–Ω—ñ—á–Ω—É –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é ‚Üí rotation invariance.

---

### Matching (–ó—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ü—Ä–æ—Ü–µ—Å –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π –º—ñ–∂ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞–º–∏ –¥–≤–æ—Ö –∑–æ–±—Ä–∞–∂–µ–Ω—å.

**–¢–∏–ø–∏**:

- **Brute-force** - –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∫–æ–∂–Ω–æ–≥–æ –∑ –∫–æ–∂–Ω–∏–º O(n¬≤)
- **Approximate NN** - —à–≤–∏–¥—à–µ, –∞–ª–µ –º–µ–Ω—à —Ç–æ—á–Ω–æ (FLANN)

---

### Hamming Distance

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ö—ñ–ª—å–∫—ñ—Å—Ç—å –±—ñ—Ç, —É —è–∫–∏—Ö –¥–≤–∞ –±—ñ–Ω–∞—Ä–Ω–∏—Ö –≤–µ–∫—Ç–æ—Ä–∏ –≤—ñ–¥—Ä—ñ–∑–Ω—è—é—Ç—å—Å—è.

**–§–æ—Ä–º—É–ª–∞**:

```
d_H(a, b) = popcount(a ‚äï b)
```

–î–µ `‚äï` - XOR, `popcount` - –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–∏–Ω–∏—Ü—å.

**–£ –∫–æ–¥—ñ**:

```python
def hamming_distance(self, desc1, desc2):
    return np.count_nonzero(desc1 != desc2)
```

**–ü—Ä–∏–∫–ª–∞–¥**:

```
a = 10110011
b = 11010001
      ‚Üì ‚Üì  ‚Üì
d_H = 3
```

---

### KNN Matching (K Nearest Neighbors)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –∑–Ω–∞—Ö–æ–¥–∏–º–æ k –Ω–∞–π–±–ª–∏–∂—á–∏—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤ –Ω–∞ –¥—Ä—É–≥–æ–º—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ.

**–£ –∫–æ–¥—ñ**:

```python
def knn_match(self, desc1, desc2, k=2):
    matches = []
    for i, d1 in enumerate(desc1):
        distances = np.array([self.hamming_distance(d1, d2) for d2 in desc2])
        k_nearest_indices = np.argpartition(distances, min(k, len(distances)-1))[:k]
        k_nearest_indices = k_nearest_indices[np.argsort(distances[k_nearest_indices])]

        k_matches = [cv2.DMatch(i, int(j), float(distances[j]))
                     for j in k_nearest_indices]
        matches.append(k_matches)

    return matches
```

**–ó–∞–∑–≤–∏—á–∞–π**: k=2 –¥–ª—è Lowe's ratio test.

---

### Lowe's Ratio Test

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ú–µ—Ç–æ–¥ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—ó —Ö–∏–±–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π —à–ª—è—Ö–æ–º –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –≤—ñ–¥—Å—Ç–∞–Ω–µ–π –¥–æ –Ω–∞–π–±–ª–∏–∂—á–∏—Ö –¥–≤–æ—Ö —Å—É—Å—ñ–¥—ñ–≤.

**–§–æ—Ä–º—É–ª–∞**:

```
match is good if d‚ÇÅ / d‚ÇÇ < threshold
```

–î–µ:

- `d‚ÇÅ` - –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Å—É—Å—ñ–¥–∞
- `d‚ÇÇ` - –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ –¥—Ä—É–≥–æ–≥–æ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ
- `threshold ‚âà 0.7-0.8`

**–£ –∫–æ–¥—ñ**:

```python
def match(self, desc1, desc2):
    knn_matches = self.knn_match(desc1, desc2, k=2)
    good_matches = []

    for matches in knn_matches:
        if len(matches) >= 2:
            m, n = matches[0], matches[1]
            if m.distance < self.ratio_threshold * n.distance:
                good_matches.append(m)

    return good_matches
```

**–Ü–Ω—Ç—É—ó—Ü—ñ—è**: –Ø–∫—â–æ –Ω–∞–π–∫—Ä–∞—â–µ —Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è –Ω–∞–±–∞–≥–∞—Ç–æ –∫—Ä–∞—â–µ –∑–∞ –¥—Ä—É–≥–µ ‚Üí –Ω–∞–¥—ñ–π–Ω–µ.

---

### DMatch

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–∏—Ö OpenCV –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ.

**–ü–æ–ª—è**:

- `queryIdx` - —ñ–Ω–¥–µ–∫—Å –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –Ω–∞ –ø–µ—Ä—à–æ–º—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ
- `trainIdx` - —ñ–Ω–¥–µ–∫—Å –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –Ω–∞ –¥—Ä—É–≥–æ–º—É –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ
- `distance` - –≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞–º–∏

**–£ –∫–æ–¥—ñ**:

```python
cv2.DMatch(i, int(j), float(distances[j]))
```

---

### RANSAC (Random Sample Consensus)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –Ü—Ç–µ—Ä–∞—Ç–∏–≤–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è —Ä–æ–±–∞—Å—Ç–Ω–æ—ó –æ—Ü—ñ–Ω–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –º–æ–¥–µ–ª—ñ –≤ –ø—Ä–∏—Å—É—Ç–Ω–æ—Å—Ç—ñ outliers.

**–ê–ª–≥–æ—Ä–∏—Ç–º**:

```
1. –ü–æ–≤—Ç–æ—Ä—é—î–º–æ max_iterations —Ä–∞–∑—ñ–≤:
   a. –í–∏–ø–∞–¥–∫–æ–≤–æ –≤–∏–±–∏—Ä–∞—î–º–æ –º—ñ–Ω—ñ–º–∞–ª—å–Ω—É –º–Ω–æ–∂–∏–Ω—É —Ç–æ—á–æ–∫
   b. –û–±—á–∏—Å–ª—é—î–º–æ –º–æ–¥–µ–ª—å –Ω–∞ —Ü–∏—Ö —Ç–æ—á–∫–∞—Ö
   c. –ü—ñ–¥—Ä–∞—Ö–æ–≤—É—î–º–æ inliers (—Ç–æ—á–∫–∏, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –º–æ–¥–µ–ª—ñ)
   d. –Ø–∫—â–æ inliers –±—ñ–ª—å—à–µ –∑–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ ‚Üí –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –º–æ–¥–µ–ª—å

2. –ü–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ –º–æ–¥–µ–ª—å –Ω–∞ –≤—Å—ñ—Ö inliers –Ω–∞–π–∫—Ä–∞—â–æ—ó —ñ—Ç–µ—Ä–∞—Ü—ñ—ó
```

**–£ –∫–æ–¥—ñ**:

```python
def find_transform(self, src_pts, dst_pts):
    best_M = None
    max_inlier_count = 0

    for _ in range(self.max_iterations):
        # –í–∏–±–∏—Ä–∞—î–º–æ 3 –≤–∏–ø–∞–¥–∫–æ–≤—ñ —Ç–æ—á–∫–∏
        indices = np.random.choice(len(src_pts), 3, replace=False)
        M = self.estimate_affine_transform(src_pts[indices], dst_pts[indices])

        # –†–∞—Ö—É—î–º–æ inliers
        inliers, inlier_mask = self.count_inliers(src_pts, dst_pts, M)

        if len(inliers) > max_inlier_count:
            max_inlier_count = len(inliers)
            # –£—Ç–æ—á–Ω—é—î–º–æ –º–æ–¥–µ–ª—å –Ω–∞ –≤—Å—ñ—Ö inliers
            M_refined = self.estimate_affine_transform(
                src_pts[inliers], dst_pts[inliers]
            )
            if M_refined is not None:
                best_M = M_refined

    return best_M, best_inlier_mask, params
```

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏**:

- `max_iterations` - –∫—ñ–ª—å–∫—ñ—Å—Ç—å —ñ—Ç–µ—Ä–∞—Ü—ñ–π (1000-2000)
- `threshold` - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è inlier (3-5 –ø—ñ–∫—Å–µ–ª—ñ–≤)
- `min_inliers` - –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å inliers –¥–ª—è –ø—Ä–∏–π–Ω—è—Ç—Ç—è –º–æ–¥–µ–ª—ñ

---

### Inliers vs Outliers

**Inliers** - —Ç–æ—á–∫–∏, —â–æ –¥–æ–±—Ä–µ –≤–ø–∏—Å—É—é—Ç—å—Å—è –≤ –º–æ–¥–µ–ª—å (< threshold)
**Outliers** - –≤–∏–∫–∏–¥–∏, –ø–æ–º–∏–ª–∫–æ–≤—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ (‚â• threshold)

**–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è**:

- üü¢ –ó–µ–ª–µ–Ω—ñ –ª—ñ–Ω—ñ—ó - inliers (–ø—Ä–∞–≤–∏–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ)
- üî¥ –ß–µ—Ä–≤–æ–Ω—ñ –ª—ñ–Ω—ñ—ó - outliers (–ø–æ–º–∏–ª–∫–æ–≤—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—ñ)

---

### Affine Transformation (–ê—Ñ—ñ–Ω–Ω–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –õ—ñ–Ω—ñ–π–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, —â–æ –∑–±–µ—Ä—ñ–≥–∞—î –ø–∞—Ä–∞–ª–µ–ª—å–Ω—ñ—Å—Ç—å –ª—ñ–Ω—ñ–π.

**–ú–∞—Ç—Ä–∏—Ü—è 2√ó3**:

```
[x']   [a  b  tx] [x]
[y'] = [c  d  ty] [y]
                  [1]
```

**–í–∫–ª—é—á–∞—î**:

- –û–±–µ—Ä—Ç–∞–Ω–Ω—è (rotation)
- –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è (scale)
- –ó–º—ñ—â–µ–Ω–Ω—è (translation)
- –ó—Å—É–≤ (shear)

**–£ –∫–æ–¥—ñ**:

```python
def estimate_affine_transform(self, src_pts, dst_pts):
    A = []
    b = []
    for (x, y), (x_prime, y_prime) in zip(src_pts, dst_pts):
        A.append([x, y, 1, 0, 0, 0])
        b.append(x_prime)
        A.append([0, 0, 0, x, y, 1])
        b.append(y_prime)

    params = np.linalg.lstsq(np.array(A), np.array(b), rcond=None)[0]
    return np.array([[params[0], params[1], params[2]],
                     [params[3], params[4], params[5]]])
```

**–ï–∫—Å—Ç—Ä–∞–∫—Ü—ñ—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤**:

```python
def extract_params(self, M):
    tx, ty = M[0, 2], M[1, 2]
    a, b, c, d = M[0, 0], M[0, 1], M[1, 0], M[1, 1]

    angle = np.degrees(np.arctan2(c, a))
    scale = (np.sqrt(a**2 + c**2) + np.sqrt(b**2 + d**2)) / 2

    return {"angle": angle, "tx": tx, "ty": ty, "scale": scale}
```

---

### FLANN (Fast Library for Approximate Nearest Neighbors)

**–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è**: –ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ approximate nearest neighbor search.

**–î–ª—è –±—ñ–Ω–∞—Ä–Ω–∏—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤**: LSH (Locality-Sensitive Hashing)

**–£ –∫–æ–¥—ñ**:

```python
FLANN_INDEX_LSH = 6
flann_matcher = cv2.FlannBasedMatcher(
    dict(algorithm=FLANN_INDEX_LSH,
         table_number=12,      # –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—å
         key_size=20,          # –¥–æ–≤–∂–∏–Ω–∞ –∫–ª—é—á–∞
         multi_probe_level=2), # —Ä—ñ–≤–µ–Ω—å multi-probing
    dict(checks=100)           # –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫
)
```

**–ü–µ—Ä–µ–≤–∞–≥–∏**: O(log n) –∑–∞–º—ñ—Å—Ç—å O(n) –¥–ª—è brute-force.

---

## –î–µ—Ç–∞–ª—å–Ω–∏–π —Ä–æ–∑–±—ñ—Ä –∫–æ–¥—É

### 1. CustomORB Class

#### –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è

```python
def __init__(self, n_features=1000, patch_size=31, n_tests=256):
    self.n_features = n_features      # –∫—ñ–ª—å–∫—ñ—Å—Ç—å keypoints
    self.patch_size = patch_size      # —Ä–æ–∑–º—ñ—Ä –ø–∞—Ç—á—É (31√ó31)
    self.n_tests = n_tests            # –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–µ—Å—Ç—ñ–≤ BRIEF (256)

    np.random.seed(42)
    half_patch = patch_size // 2
    # –ì–µ–Ω–µ—Ä—É—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ –ø–∞—Ä–∏ —Ç–æ—á–æ–∫ –¥–ª—è BRIEF
    self.test_points = np.random.randint(
        -half_patch + 2, half_patch - 2, size=(n_tests, 4)
    )
```

**–ß–æ–º—É +2 —Ç–∞ -2?** –©–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ –∫—Ä–∞—ó–≤ –ø–∞—Ç—á—É –ø—Ä–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞—Ö.

---

#### –í–∏—è–≤–ª–µ–Ω–Ω—è –∫–ª—é—á–æ–≤–∏—Ö —Ç–æ—á–æ–∫

```python
def detect_keypoints(self, gray_img):
    harris = self.compute_harris_response(gray_img)

    # Non-maximum suppression
    kernel_size = 9
    harris_dilated = cv2.dilate(harris, np.ones((kernel_size, kernel_size)))

    # –ü–æ—Ä—ñ–≥ —ñ –º–∞—Å–∫–∞ –ª–æ–∫–∞–ª—å–Ω–∏—Ö –º–∞–∫—Å–∏–º—É–º—ñ–≤
    threshold = 0.001 * harris.max()
    keypoint_mask = (harris > threshold) & (harris == harris_dilated)
    keypoints_coords = np.argwhere(keypoint_mask)

    # –í–∏–±–∏—Ä–∞—î–º–æ top N –∑–∞ response
    if len(keypoints_coords) > self.n_features:
        responses = harris[keypoints_coords[:, 0], keypoints_coords[:, 1]]
        top_indices = np.argsort(responses)[-self.n_features:]
        keypoints_coords = keypoints_coords[top_indices]

    return [cv2.KeyPoint(float(x), float(y), self.patch_size,
                         response=float(harris[y, x]))
            for y, x in keypoints_coords]
```

**–í–∞–∂–ª–∏–≤—ñ –º–æ–º–µ–Ω—Ç–∏**:

1. NMS –∑ kernel 9√ó9 –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–æ–∑–ø–æ–¥—ñ–ª—É —Ç–æ—á–æ–∫
2. Threshold = 0.1% –≤—ñ–¥ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ response
3. –°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ response –¥–ª—è –≤–∏–±–æ—Ä—É –Ω–∞–π–∫—Ä–∞—â–∏—Ö

---

#### –û–±—á–∏—Å–ª–µ–Ω–Ω—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ –∑ –ø–æ–≤–æ—Ä–æ—Ç–æ–º

```python
def compute_descriptor(self, gray_img, keypoint, angle):
    x, y = int(keypoint.pt[0]), int(keypoint.pt[1])
    half_patch = self.patch_size // 2

    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –º–µ–∂
    if (y - half_patch < 0 or y + half_patch >= gray_img.shape[0] or
        x - half_patch < 0 or x + half_patch >= gray_img.shape[1]):
        return None

    # –ü–æ–≤–æ—Ä–æ—Ç test points –Ω–∞ –∫—É—Ç angle
    cos_a, sin_a = np.cos(angle), np.sin(angle)
    rotated = np.zeros_like(self.test_points, dtype=np.int32)
    rotated[:, 0] = cos_a * self.test_points[:, 0] - sin_a * self.test_points[:, 1]
    rotated[:, 1] = sin_a * self.test_points[:, 0] + cos_a * self.test_points[:, 1]
    rotated[:, 2] = cos_a * self.test_points[:, 2] - sin_a * self.test_points[:, 3]
    rotated[:, 3] = sin_a * self.test_points[:, 2] + cos_a * self.test_points[:, 3]

    # –û–±—á–∏—Å–ª—é—î–º–æ BRIEF
    descriptor = np.zeros(self.n_tests, dtype=np.uint8)
    for i, (x1, y1, x2, y2) in enumerate(rotated):
        px1, py1 = y + y1, x + x1
        px2, py2 = y + y2, x + x2

        if (0 <= px1 < gray_img.shape[0] and 0 <= py1 < gray_img.shape[1] and
            0 <= px2 < gray_img.shape[0] and 0 <= py2 < gray_img.shape[1]):
            descriptor[i] = 1 if gray_img[px1, py1] < gray_img[px2, py2] else 0

    return descriptor
```

**Rotation matrix**:

```
[cos Œ∏  -sin Œ∏]
[sin Œ∏   cos Œ∏]
```

---

### 2. CustomMatcher Class

```python
class CustomMatcher:
    def __init__(self, ratio_threshold=0.75):
        self.ratio_threshold = ratio_threshold  # Lowe's ratio
```

**ratio_threshold**:

- 0.7 - strict (–º–µ–Ω—à–µ matches, –±—ñ–ª—å—à–µ —Ç–æ—á–Ω–æ—Å—Ç—ñ)
- 0.75 - balanced
- 0.8 - relaxed (–±—ñ–ª—å—à–µ matches, –º–µ–Ω—à–µ —Ç–æ—á–Ω–æ—Å—Ç—ñ)

---

### 3. CustomRANSAC Class

#### –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ inliers

```python
def count_inliers(self, src_pts, dst_pts, M):
    # –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—é
    pts_homogeneous = np.column_stack([src_pts, np.ones(len(src_pts))])
    transformed = pts_homogeneous @ M.T

    # –û–±—á–∏—Å–ª—é—î–º–æ Euclidean distance
    distances = np.linalg.norm(transformed - dst_pts, axis=1)

    # –¢–æ—á–∫–∏ –≤ –º–µ–∂–∞—Ö threshold - inliers
    inlier_mask = distances < self.threshold
    return np.where(inlier_mask)[0], inlier_mask
```

**–ß–æ–º—É Euclidean distance?** –í–∏–º—ñ—Ä—é—î–º–æ, –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Ç–æ—á–∫–∞ –ø—ñ—Å–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó –±–ª–∏–∑—å–∫–∞ –¥–æ –æ—á—ñ–∫—É–≤–∞–Ω–æ—ó –ø–æ–∑–∏—Ü—ñ—ó.

---

### 4. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π

```python
def draw_matches_custom(img1, kp1, img2, kp2, matches, inlier_mask=None, max_matches=50):
    # –°—Ç–≤–æ—Ä—é—î–º–æ –ø–∞–Ω–æ—Ä–∞–º—É
    h1, w1 = img1.shape[:2]
    h2, w2 = img2.shape[:2]
    h, w = max(h1, h2), w1 + w2

    panorama = np.zeros((h, w, 3), dtype=np.uint8)
    panorama[0:h1, 0:w1] = img1
    panorama[0:h2, w1:w1+w2] = img2

    # –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—ó –º—ñ–∂ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç—è–º–∏
    for i, match in enumerate(display_matches):
        pt1 = tuple(map(int, kp1[match.queryIdx].pt))
        pt2 = (int(kp2[match.trainIdx].pt[0]) + w1,
               int(kp2[match.trainIdx].pt[1]))

        # –ö–æ–ª—ñ—Ä –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ inlier/outlier
        color = ((0, 255, 0) if display_mask is not None and display_mask[i]
                 else (255, 0, 0) if display_mask is not None
                 else (0, 255, 255))

        cv2.line(panorama, pt1, pt2, color, 2)      # –∂–∏—Ä–Ω—ñ—à–∞ –ª—ñ–Ω—ñ—è
        cv2.circle(panorama, pt1, 4, color, -1)     # –±—ñ–ª—å—à—ñ –∫—Ä—É–∂–µ—á–∫–∏
        cv2.circle(panorama, pt2, 4, color, -1)

    return panorama
```

---

## –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏

### 1. Harris Corner Response

**–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–∞ –º–∞—Ç—Ä–∏—Ü—è**:

```
M = Œ£ w(x,y) [I‚Çì¬≤   I‚ÇìI·µß]
             [I‚ÇìI·µß  I·µß¬≤  ]
```

–î–µ `w(x,y)` - Gaussian window

**Corner response**:

```
R = det(M) - k¬∑trace¬≤(M)
  = Œª‚ÇÅŒª‚ÇÇ - k(Œª‚ÇÅ + Œª‚ÇÇ)¬≤
```

**–Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è –≤–ª–∞—Å–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å**:

- Œª‚ÇÅ ‚âà Œª‚ÇÇ ‚âà 0 ‚Üí flat region
- Œª‚ÇÅ >> Œª‚ÇÇ (or Œª‚ÇÇ >> Œª‚ÇÅ) ‚Üí edge
- Œª‚ÇÅ ‚âà Œª‚ÇÇ, both large ‚Üí corner

---

### 2. Least Squares –¥–ª—è Affine Transform

**–°–∏—Å—Ç–µ–º–∞ —Ä—ñ–≤–Ω—è–Ω—å**:

```
x' = ax + by + tx
y' = cx + dy + ty
```

**–ú–∞—Ç—Ä–∏—á–Ω–∞ —Ñ–æ—Ä–º–∞** (–¥–ª—è N —Ç–æ—á–æ–∫):

```
[x‚ÇÅ  y‚ÇÅ  1  0   0   0 ] [a ]   [x'‚ÇÅ]
[0   0   0  x‚ÇÅ  y‚ÇÅ  1 ] [b ]   [y'‚ÇÅ]
[x‚ÇÇ  y‚ÇÇ  1  0   0   0 ] [tx]   [x'‚ÇÇ]
[0   0   0  x‚ÇÇ  y‚ÇÇ  1 ] [c ] = [y'‚ÇÇ]
[...               ... ] [d ]   [...]
                         [ty]
```

**–†–æ–∑–≤'—è–∑–æ–∫**: `params = (A·µÄA)‚Åª¬πA·µÄb` –∞–±–æ `np.linalg.lstsq(A, b)`

---

### 3. Rotation Angle –∑ Affine Matrix

```
M = [a  b  tx]   [s¬∑cos Œ∏  -s¬∑sin Œ∏  tx]
    [c  d  ty] = [s¬∑sin Œ∏   s¬∑cos Œ∏  ty]
```

–ó –ø–µ—Ä—à–æ–≥–æ —Å—Ç–æ–≤–ø—Ü—è:

```
a = s¬∑cos Œ∏
c = s¬∑sin Œ∏

Œ∏ = atan2(c, a)
s = ‚àö(a¬≤ + c¬≤)
```

---

## –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è Custom vs OpenCV

### –¢–æ—á–Ω—ñ—Å—Ç—å

| –ú–µ—Ç—Ä–∏–∫–∞           | Custom    | OpenCV   |
| ----------------- | --------- | -------- |
| Keypoints         | ~1000     | ~1000    |
| Harris threshold  | 0.001¬∑max | Adaptive |
| NMS kernel        | 9√ó9       | Adaptive |
| BRIEF tests       | 256       | 256      |
| Ratio test        | 0.75      | 0.75     |
| RANSAC iterations | 2000      | 1000     |

### –®–≤–∏–¥–∫–æ–¥—ñ—è

- **Detection**: OpenCV ~2-3√ó —à–≤–∏–¥—à–µ (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π C++)
- **Matching**: FLANN ~5-10√ó —à–≤–∏–¥—à–µ –∑–∞ brute-force
- **RANSAC**: –ü—Ä–∏–±–ª–∏–∑–Ω–æ –æ–¥–Ω–∞–∫–æ–≤—ñ

### –ü–µ—Ä–µ–≤–∞–≥–∏ Custom

‚úÖ –ü–æ–≤–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
‚úÖ –†–æ–∑—É–º—ñ–Ω–Ω—è –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤
‚úÖ –ú–æ–∂–ª–∏–≤—ñ—Å—Ç—å –∫–∞—Å—Ç–æ–º—ñ–∑–∞—Ü—ñ—ó

### –ü–µ—Ä–µ–≤–∞–≥–∏ OpenCV

‚úÖ –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –∫–æ–¥
‚úÖ Scale-space pyramid
‚úÖ Adaptive thresholding
‚úÖ Production-ready

---

## –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ø–æ—Ä–∞–¥–∏

### –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤

**n_features** (1000):

- –ë—ñ–ª—å—à–µ ‚Üí –∫—Ä–∞—â–µ coverage, –∞–ª–µ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ
- –ú–µ–Ω—à–µ ‚Üí —à–≤–∏–¥—à–µ, –∞–ª–µ –º–æ–∂–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –≤–∞–∂–ª–∏–≤—ñ features

**ratio_threshold** (0.75):

- –ú–µ–Ω—à–µ (0.7) ‚Üí –º–µ–Ω—à–µ matches, –±—ñ–ª—å—à–µ precision
- –ë—ñ–ª—å—à–µ (0.8) ‚Üí –±—ñ–ª—å—à–µ matches, –º–µ–Ω—à–µ precision

**RANSAC threshold** (5.0 –ø—ñ–∫—Å–µ–ª—ñ–≤):

- –ú–µ–Ω—à–µ (3.0) ‚Üí —Å—Ç—Ä–æ–≥—ñ—à–∞ –º–æ–¥–µ–ª—å, –º–µ–Ω—à–µ inliers
- –ë—ñ–ª—å—à–µ (7.0) ‚Üí –º'—è–∫—à–∞ –º–æ–¥–µ–ª—å, –±—ñ–ª—å—à–µ inliers

**RANSAC iterations** (2000):

- –ë—ñ–ª—å—à–µ ‚Üí –≤–∏—â–∞ –≤—ñ—Ä–æ–≥—ñ–¥–Ω—ñ—Å—Ç—å –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –Ω–∞–π–∫—Ä–∞—â–æ—ó –º–æ–¥–µ–ª—ñ
- –§–æ—Ä–º—É–ª–∞: `k = log(1-p) / log(1-w¬≥)` –¥–µ p=0.99, w=inlier_ratio

### –¢–∏–ø–æ–≤—ñ –ø—Ä–æ–±–ª–µ–º–∏

**–ú–∞–ª–æ matches**:

- ‚úÖ –ó–±—ñ–ª—å—à–∏—Ç–∏ n_features
- ‚úÖ Relaxed ratio_threshold (0.8)
- ‚úÖ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —è–∫—ñ—Å—Ç—å –∑–æ–±—Ä–∞–∂–µ–Ω—å

**RANSAC fails**:

- ‚úÖ –ó–±—ñ–ª—å—à–∏—Ç–∏ threshold (5.0 ‚Üí 7.0)
- ‚úÖ –ó–º–µ–Ω—à–∏—Ç–∏ min_inliers
- ‚úÖ –ë—ñ–ª—å—à–µ iterations

**–ü–æ–≤—ñ–ª—å–Ω–∞ —Ä–æ–±–æ—Ç–∞**:

- ‚úÖ –ó–º–µ–Ω—à–∏—Ç–∏ n_features
- ‚úÖ –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ FLANN –∑–∞–º—ñ—Å—Ç—å brute-force
- ‚úÖ –ó–º–µ–Ω—à–∏—Ç–∏ RANSAC iterations

---

## –í–∏—Å–Ω–æ–≤–∫–∏

### –ö–ª—é—á–æ–≤—ñ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—ó

1. **Feature detection** - –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–∏—Ö —Ç–æ—á–æ–∫
2. **Descriptor** - –∫–æ–º–ø–∞–∫—Ç–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –æ–∫–æ–ª–∏—Ü—ñ
3. **Matching** - –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ñ–≤
4. **RANSAC** - —Ä–æ–±–∞—Å—Ç–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ –º–æ–¥–µ–ª—ñ

### Pipeline ORB matching

```
Image ‚Üí Grayscale ‚Üí Harris corners ‚Üí Top N keypoints
     ‚Üí Orientation ‚Üí Rotated BRIEF ‚Üí Descriptors

Descriptors‚ÇÅ + Descriptors‚ÇÇ ‚Üí Hamming distance ‚Üí KNN
     ‚Üí Lowe's ratio test ‚Üí Good matches

Matches ‚Üí RANSAC ‚Üí Affine transform + Inliers
```

### –ü—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è

- üì∏ Image stitching (–ø–∞–Ω–æ—Ä–∞–º–∏)
- üéØ Object recognition
- üìπ Visual odometry
- üéÆ AR/VR tracking
- ü§ñ SLAM (Simultaneous Localization and Mapping)

---

_–î–æ–∫—É–º–µ–Ω—Ç —Å—Ç–≤–æ—Ä–µ–Ω–æ –¥–ª—è –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ 2_
_–ö—É—Ä—Å: –û–±—Ä–æ–±–∫–∞ –∑–æ–±—Ä–∞–∂–µ–Ω—å –º–µ—Ç–æ–¥–∞–º–∏ —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É_
_–ù–∞—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏–π —É–Ω—ñ–≤–µ—Ä—Å–∏—Ç–µ—Ç ¬´–õ—å–≤—ñ–≤—Å—å–∫–∞ –ø–æ–ª—ñ—Ç–µ—Ö–Ω—ñ–∫–∞¬ª_
